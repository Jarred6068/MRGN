# Internal routine
# List new trios based on new edges added into a network (using a prior 'trio analysis')
enumerate.trios.new <- function (Adj,        # new adjacency matrix
                                 new.edges,  # logical vector indicating presence of a new edge
                                 old.Adj,    # old adjacency matrix
                                 trio.set,   # set of trios (in which new edges were added or not)
                                 q, p = NROW(Adj) - q, # numbers of V-nodes and T-nodes, respectively
                                 cl = NULL,
                                 chunk.size = NULL) {
  # Extract the set of trios with newly added edges
  subtrio.set <- trio.set[new.edges,, drop = FALSE]

  # Find additional trios generated by the new edge
  new.trio.set <- matteApply(subtrio.set, MARGIN = 1,
                             FUN = enumerate.trios.new.i,
                             Adj = Adj,
                             old.Adj = old.Adj,
                             Vlabels = 1:q, # Labels (numbers) for all V-nodes
                             Tlabels = (1 + q):(p + q), # Labels (numbers) for all T-nodes
                             chunk.size = chunk.size,
                             simplify = FALSE,
                             cl = cl)
  new.trio.set <- do.call('rbind', new.trio.set)
  if (is.null(new.trio.set)) { # no new trio generated by the new edge
    return(matrix(0, ncol = 3, nrow = 0))
  }
  else {
    new.trio.set <- unique(new.trio.set) # trios generated by the new edges
    set0 <- trio.identifyer(trio.set) # unique identifiers for already analysed trios
    set1 <- trio.identifyer(new.trio.set) # unique identifiers for new trios
    keep <- !is.element(set1, set0) # keep only new trios
    new.trio.set <- new.trio.set[keep, , drop = FALSE]
    row.names(new.trio.set) <- NULL
    return(new.trio.set)
  }
}

# Parallelized version of 'enumerate.trios.new'
# NO LONGER USED; DELETE
enumerate.trios.new.parallel <- function (Adj,        # new adjacency matrix
                                 new.edges,  # logical vector indicating presence of a new edge
                                 old.Adj,    # old adjacency matrix
                                 trio.set,   # set of trios (in which new edges were added or not)
                                 q, p = NROW(Adj) - q,
                                 cl) { # numbers of V-nodes and T-nodes, respectively
  # Extract the set of trios with newly added edges
  subtrio.set = trio.set[new.edges,, drop = FALSE]

  # Find additional trios generated by the new edge
  new.trio.set <- parallel::parLapply(cl = cl,
                                     X = 1:NROW(subtrio.set),
                                     fun = function(i) {
                                       enumerate.trios.new.i (subtrio.set[i,],
                                                              Adj = Adj,
                                                              old.Adj = old.Adj,
                                                              Vlabels = 1:q, # Labels (numbers) for all V-nodes
                                                              Tlabels = (1 + q):(p + q)) # Labels (numbers) for all T-nodes
                                     })
  new.trio.set <- do.call('rbind', new.trio.set)
  if (is.null(new.trio.set)) { # no new trio generated by the new edge
    return(matrix(0, ncol = 3, nrow = 0))
  }
  else {
    new.trio.set <- unique(new.trio.set) # trios generated by the new edges
    set0 <- trio.identifyer(trio.set) # unique identifiers for already analysed trios
    set1 <- trio.identifyer(new.trio.set) # unique identifiers for new trios
    keep <- !is.element(set1, set0) # keep only new trios
    new.trio.set <- new.trio.set[keep, , drop = FALSE]
    row.names(new.trio.set) <- NULL
    return(new.trio.set)
  }
}

# Child function for 'enumerate.trios.new'
enumerate.trios.new.i <- function(col.indices,
                                  Adj,
                                  old.Adj,
                                  Vlabels,
                                  Tlabels) {
  old.Aijk <- old.Adj[col.indices, col.indices]
  Aijk <- Adj[col.indices, col.indices]
  # Determine if the new edge is V --> T or T --> T (or T -- T) and find new possible trios
  if (Aijk[1,2] - old.Aijk[1,2] > 0) { # When V --> T1 is the new edge
    # Find trios of the form T3 <-- V --> T1
    Tlabelk <- Adj[col.indices[1], Tlabels] > 0    # T nodes linked to V
    Tlabelk <- Tlabels[Tlabelk]                    # Replace logicals by labels
    Tlabelk <- setdiff (Tlabelk, col.indices[-1])  # Exclude T1 and T2
    res <- if (length(Tlabelk)) {
      cbind(Vi = col.indices[1], Tj = col.indices[2], Tk = Tlabelk)
    }
    # Find trios of the form V --> T1 -- T3
    Tlabelk <- (Adj[col.indices[2], Tlabels] +
                  Adj[Tlabels, col.indices[2]]) > 0 # T nodes linked to T1
    Tlabelk <- Tlabels[Tlabelk]                     # Replace logicals by labels
    Tlabelk <- setdiff (Tlabelk, col.indices[3])    # Exclude T2
    res <- rbind(res, if (length(Tlabelk)) {
      cbind(Vi = col.indices[1], Tj = col.indices[2], Tk = Tlabelk)
    })
    res <- unique(res)
  }
  else if (Aijk[1,3] - old.Aijk[1,3] > 0)  { # When V --> T2 is the new edge
    # Find trios of the form T3 <-- V --> T2
    Tlabelk <- Adj[col.indices[1], Tlabels] > 0    # T nodes linked to V
    Tlabelk <- Tlabels[Tlabelk]                    # Replace logicals by labels
    Tlabelk <- setdiff (Tlabelk, col.indices[-1])  # Exclude T1 and T2
    res <- if (length(Tlabelk)) {
      cbind(Vi = col.indices[1], Tj = col.indices[3], Tk = Tlabelk)
    }
    # Find trios of the form V --> T1 -- T3
    Tlabelk <- (Adj[col.indices[3], Tlabels] +
                  Adj[Tlabels, col.indices[3]]) > 0 # T nodes linked to T2
    Tlabelk <- Tlabels[Tlabelk]                     # Replace logicals by labels
    Tlabelk <- setdiff (Tlabelk, col.indices[2])    # Exclude T1
    res <- rbind(res, if (length(Tlabelk)) {
      cbind(Vi = col.indices[1], Tj = col.indices[3], Tk = Tlabelk)
    })
    res <- unique(res)
  }
  else { # When T1 -- T2 is the new edge
    if (Aijk[2,3] + Aijk[3,2] == 2) { # If the new edge is undirected
      # Find all V nodes linked to T1 or T2
      Vlabelk <- (Adj[Vlabels, col.indices[2]] +
                    Adj[Vlabels, col.indices[3]]) > 0 # V nodes linked to T1 or T2
      Vlabelk <- Vlabels[Vlabelk]                    # Replace logicals by labels
      Vlabelk <- setdiff (Vlabelk, col.indices[1])   # Exclude Vi
      res <- if (length(Vlabelk)) {
        cbind(Vi = Vlabelk, Tj = col.indices[2], Tk = col.indices[3])
      }
    }
    else { # If the edge is directed,
      # Find all V nodes only linked to either T1 or T2 (not both)
      Vlabelk <- (Adj[Vlabels, col.indices[2]] +
                    Adj[Vlabels, col.indices[3]]) == 1 # V nodes linked to T1 or T2
      Vlabelk <- Vlabels[Vlabelk]                    # Replace logicals by labels
      Vlabelk <- setdiff (Vlabelk, col.indices[1])   # Exclude Vi
      res <- if (length(Vlabelk)) {
        cbind(Vi = Vlabelk, Tj = col.indices[2], Tk = col.indices[3])
      }
    }
  }
  return(res)
}

# Generate unique identifiers for trios
trio.identifyer <- function(trioset) {
  # order T1 and T2
  trioset[,2:3] <- t(apply(trioset[,2:3, drop = FALSE], MARGIN = 1, FUN = sort))
  # Generate IDs
  paste0(trioset[,1], '.', trioset[,2], '.', trioset[,3])
}
