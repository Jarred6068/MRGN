return.means=TRUE, rplot=4, nplot=1, save.plot=FALSE, plot.path=""){
library(ggpubr)
pd=position_dodge(dodge)
if(by.class==TRUE){
#calc averages within a certain model class
metrics.mrgn.m=subset(metrics.mrgn, truth==which.class)
metrics.mrpc.m=subset(metrics.mrpc, truth==which.class)
#get mean scores across parameter within class
avg.scores.all=get.avg(x.mrgn = metrics.mrgn.m,
x.mrpc = metrics.mrpc.m,
params = params,
which.param = which.param)
}else{
#get mean scores across parameter
avg.scores.all=get.avg(x.mrgn = metrics.mrgn,
x.mrpc = metrics.mrpc,
params = params,
which.param = which.param)
}
#plotting - splined plots
if(plot.it==TRUE & spline.it==TRUE){
#for plot saving
if(save.plot==TRUE){
png(plot.path)
plot.spline(avg.scores.all,
pd = pd,
spline.int = spline.int,
params = params,
which.param = which.param,
rplot = rplot,
nplot = nplot)
dev.off()
}else{
plot.spline(avg.scores.all,
pd = pd,
spline.int = spline.int,
params = params,
which.param = which.param,
rplot = rplot,
nplot = nplot)
}
#plotting - regular plots
}else if(plot.it==TRUE & spline.it==FALSE){
if(save.plot==TRUE){
png(plot.path)
plot.regular(Data = avg.scores.all,
pd = pd,
params = params,
which.param = which.param,
rplot = rplot,
nplot = nplot)
dev.off()
}else{
plot.regular(Data = avg.scores.all,
pd = pd,
params = params,
which.param = which.param,
rplot = rplot,
nplot = nplot)
}
}
#return mean score and sdev data
if(return.means==TRUE){
return(avg.scores.all)
}
}
small.datasets.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrgn_1k_datasets_wpc2small.RData")
small.reg.res.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrgn_1k_regres_results_wpc2small.RData")
small.inf.mods.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrgn_1k_inf_results_wpc2small.RData")
small.mrpc.inf.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrpc_1k_small_results_wpc2small.RData")
small.params.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrpc_v_mrgn_1k_params_wpc2small.RData")
small.mrpc.inf=lapply(small.mrpc.inf.wpc, function(x,i) x[[i]], i=1)
small.mrpc.adj=lapply(small.mrpc.inf.wpc, function(x,i) x[[i]], i=2)
model.truth.sm=convert.truth(small.params.wpc$model)
small.inf.cats=convert.cats(small.inf.mods.wpc)
small.mrpc.inf.cats=convert.cats(unlist(small.mrpc.inf))
kable(table(Truth=model.truth.sm, Inferred=small.inf.cats), caption = "Confusion matrix showing the performance of MRGN in inferring models M0 and M1 in the presence of confounding variables in scenario 2")
kable(table(Truth=model.truth.sm, Inferred=small.mrpc.inf.cats), caption = "Confusion matrix showing the performance of MRPC in inferring models M0 and M1 in the presence of confounding variables scenario 2")
small.mrgn.metrics.wpc=as.data.frame(matrix(0, nrow = 1000, ncol = 4))
small.mrpc.metrics.wpc=as.data.frame(matrix(0, nrow = 1000, ncol = 4))
colnames(small.mrgn.metrics.wpc)=c("prec_edge", "recall", "specificity", "FOR")
colnames(small.mrpc.metrics.wpc)=c("prec_edge", "recall", "specificity", "FOR")
for(i in 1:1000){
small.mrgn.metrics.wpc[i,]=get.metrics(Truth = model.truth.sm[i],
Inferred = small.inf.cats[i], get.adj.inf = TRUE)
small.mrpc.metrics.wpc[i,]=get.metrics(Truth = model.truth.sm[i],
Inferred = small.mrpc.inf.cats[i], get.adj.inf = TRUE)
}
small.mrgn.metrics.wpc=cbind.data.frame(Method=rep("MRGN",1000), truth=model.truth.sm, inf=small.inf.cats)
small.mrpc.metrics.wpc=cbind.data.frame(Method=rep("MRPC",1000), truth=model.truth.sm, inf=small.mrpc.inf.cats)
#calculate performance across confounders
# num.conf=unique(small.params.wpc$number.of.conf)
# mean.met.conf.mrgn=as.data.frame(matrix(0, nrow = length(num.conf), ncol = 4))
# mean.met.conf.mrpc=as.data.frame(matrix(0, nrow = length(num.conf), ncol = 4))
# for(i in 1:length(num.conf)){
#
# }
plot.sim.metrics(metrics.mrgn=small.mrgn.metrics.wpc,
metrics.mrpc=small.mrpc.metrics.wpc,
params=small.params.wpc,
which.param=6,
by.class=FALSE,
which.class=NULL,
plot.it=TRUE,
spline.it=TRUE,
spline.int=15,
dodge=0.1,
return.means=FALSE,
rplot=4,
nplot=1,
save.plot=FALSE,
plot.path="")
head(small.mrgn.metrics.wpc)
get.avg(x.mrgn = small.mrgn.metrics.wpc, x.mrpc = small.mrpc.metrics.wpc, params = small.params.wpc, which.param = 6)
debug(get.avg)
get.avg(x.mrgn = small.mrgn.metrics.wpc, x.mrpc = small.mrpc.metrics.wpc, params = small.params.wpc, which.param = 6)
get.avg(x.mrgn = small.mrgn.metrics.wpc, x.mrpc = small.mrpc.metrics.wpc, params = small.params.wpc, which.param = 6)
x.mrgn[which(params[,which.param]==x[i]),-c(1:3)]
which(params[,which.param]==x[i])
x.mrgn[141,]
small.datasets.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrgn_1k_datasets_wpc2small.RData")
small.reg.res.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrgn_1k_regres_results_wpc2small.RData")
small.inf.mods.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrgn_1k_inf_results_wpc2small.RData")
small.mrpc.inf.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrpc_1k_small_results_wpc2small.RData")
small.params.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrpc_v_mrgn_1k_params_wpc2small.RData")
small.mrpc.inf=lapply(small.mrpc.inf.wpc, function(x,i) x[[i]], i=1)
small.mrpc.adj=lapply(small.mrpc.inf.wpc, function(x,i) x[[i]], i=2)
model.truth.sm=convert.truth(small.params.wpc$model)
small.inf.cats=convert.cats(small.inf.mods.wpc)
small.mrpc.inf.cats=convert.cats(unlist(small.mrpc.inf))
kable(table(Truth=model.truth.sm, Inferred=small.inf.cats), caption = "Confusion matrix showing the performance of MRGN in inferring models M0 and M1 in the presence of confounding variables in scenario 2")
kable(table(Truth=model.truth.sm, Inferred=small.mrpc.inf.cats), caption = "Confusion matrix showing the performance of MRPC in inferring models M0 and M1 in the presence of confounding variables scenario 2")
small.mrgn.metrics.wpc=as.data.frame(matrix(0, nrow = 1000, ncol = 4))
small.mrpc.metrics.wpc=as.data.frame(matrix(0, nrow = 1000, ncol = 4))
colnames(small.mrgn.metrics.wpc)=c("prec_edge", "recall", "specificity", "FOR")
colnames(small.mrpc.metrics.wpc)=c("prec_edge", "recall", "specificity", "FOR")
for(i in 1:1000){
small.mrgn.metrics.wpc[i,]=get.metrics(Truth = model.truth.sm[i],
Inferred = small.inf.cats[i], get.adj.inf = TRUE)
small.mrpc.metrics.wpc[i,]=get.metrics(Truth = model.truth.sm[i],
Inferred = small.mrpc.inf.cats[i], get.adj.inf = TRUE)
}
small.mrgn.metrics.wpc=cbind.data.frame(Method=rep("MRGN",1000), truth=model.truth.sm, inf=small.inf.cats,
small.mrgn.metrics.wpc)
small.mrpc.metrics.wpc=cbind.data.frame(Method=rep("MRPC",1000), truth=model.truth.sm, inf=small.mrpc.inf.cats,
small.mrpc.metrics.wpc)
#calculate performance across confounders
# num.conf=unique(small.params.wpc$number.of.conf)
# mean.met.conf.mrgn=as.data.frame(matrix(0, nrow = length(num.conf), ncol = 4))
# mean.met.conf.mrpc=as.data.frame(matrix(0, nrow = length(num.conf), ncol = 4))
# for(i in 1:length(num.conf)){
#
# }
plot.sim.metrics(metrics.mrgn=small.mrgn.metrics.wpc,
metrics.mrpc=small.mrpc.metrics.wpc,
params=small.params.wpc,
which.param=6,
by.class=FALSE,
which.class=NULL,
plot.it=TRUE,
spline.it=TRUE,
spline.int=15,
dodge=0.1,
return.means=FALSE,
rplot=4,
nplot=1,
save.plot=FALSE,
plot.path="")
plot.sim.metrics(metrics.mrgn=small.mrgn.metrics.wpc,
metrics.mrpc=small.mrpc.metrics.wpc,
params=small.params.wpc,
which.param=6,
by.class=FALSE,
which.class=NULL,
plot.it=TRUE,
spline.it=TRUE,
spline.int=15,
dodge=0.1,
return.means=FALSE,
rplot=4,
nplot=1,
save.plot=FALSE,
plot.path="")
small.datasets.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrgn_1k_datasets_wpc2small.RData")
small.reg.res.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrgn_1k_regres_results_wpc2small.RData")
small.inf.mods.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrgn_1k_inf_results_wpc2small.RData")
small.mrpc.inf.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrpc_1k_small_results_wpc2small.RData")
small.params.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrpc_v_mrgn_1k_params_wpc2small.RData")
small.mrpc.inf=lapply(small.mrpc.inf.wpc, function(x,i) x[[i]], i=1)
small.mrpc.adj=lapply(small.mrpc.inf.wpc, function(x,i) x[[i]], i=2)
model.truth.sm=convert.truth(small.params.wpc$model)
small.inf.cats=convert.cats(small.inf.mods.wpc)
small.mrpc.inf.cats=convert.cats(unlist(small.mrpc.inf))
kable(table(Truth=model.truth.sm, Inferred=small.inf.cats), caption = "Confusion matrix showing the performance of MRGN in inferring models M0 and M1 in the presence of confounding variables in scenario 2")
kable(table(Truth=model.truth.sm, Inferred=small.mrpc.inf.cats), caption = "Confusion matrix showing the performance of MRPC in inferring models M0 and M1 in the presence of confounding variables scenario 2")
small.mrgn.metrics.wpc=as.data.frame(matrix(0, nrow = 1000, ncol = 4))
small.mrpc.metrics.wpc=as.data.frame(matrix(0, nrow = 1000, ncol = 4))
colnames(small.mrgn.metrics.wpc)=c("prec_edge", "recall", "specificity", "FOR")
colnames(small.mrpc.metrics.wpc)=c("prec_edge", "recall", "specificity", "FOR")
for(i in 1:1000){
small.mrgn.metrics.wpc[i,]=get.metrics(Truth = model.truth.sm[i],
Inferred = small.inf.cats[i], get.adj.inf = TRUE)
small.mrpc.metrics.wpc[i,]=get.metrics(Truth = model.truth.sm[i],
Inferred = small.mrpc.inf.cats[i], get.adj.inf = TRUE)
}
small.mrgn.metrics.wpc=cbind.data.frame(Method=rep("MRGN",1000), truth=model.truth.sm, inf=small.inf.cats,
small.mrgn.metrics.wpc)
small.mrpc.metrics.wpc=cbind.data.frame(Method=rep("MRPC",1000), truth=model.truth.sm, inf=small.mrpc.inf.cats,
small.mrpc.metrics.wpc)
#calculate performance across confounders
# num.conf=unique(small.params.wpc$number.of.conf)
# mean.met.conf.mrgn=as.data.frame(matrix(0, nrow = length(num.conf), ncol = 4))
# mean.met.conf.mrpc=as.data.frame(matrix(0, nrow = length(num.conf), ncol = 4))
# for(i in 1:length(num.conf)){
#
# }
plot.sim.metrics(metrics.mrgn=small.mrgn.metrics.wpc,
metrics.mrpc=small.mrpc.metrics.wpc,
params=small.params.wpc,
which.param=6,
by.class=FALSE,
which.class=NULL,
plot.it=TRUE,
spline.it=TRUE,
spline.int=15,
dodge=0.1,
return.means=FALSE,
rplot=4,
nplot=1,
save.plot=FALSE,
plot.path="")
##############################################
get.avg=function(x.mrgn=NULL, x.mrpc=NULL, params=NULL, which.param=2){
#sort unique simulation parameter values
x=sort(unique(params[,which.param]))
#preallocate
x.mean.mrgn=as.data.frame(matrix(0, nrow = length(x), ncol = 9))
x.mean.mrpc=as.data.frame(matrix(0, nrow = length(x), ncol = 9))
colnames(x.mean.mrgn)=c("param.value","precision","recall","specificity","FOR", "se.prec",
"se.recall","se.specif","se_FOR")
colnames(x.mean.mrpc)=c("param.value","precision","recall","specificity","FOR", "se.prec",
"se.recall","se.specif","se_FOR")
#calculate mean across signal values
for(i in 1:length(x)){
#calc means and sdevs for mrgn (remove method and inf columns)
x.mean.mrgn[i,1]=x[i]
if(length(which(params[,which.param]==x[i]))==1){
x.mean.mrgn[i,2:5]=x.mrgn[which(params[,which.param]==x[i]),-c(1:3)]
x.mean.mrgn[i,6:9]=rep(NA, 4)
}else{
x.mean.mrgn[i,2:5]=apply(x.mrgn[which(params[,which.param]==x[i]),-c(1:3)], 2, mean, na.rm=TRUE)
x.mean.mrgn[i,6:9]=apply(x.mrgn[which(params[,which.param]==x[i]),-c(1:3)], 2, sd, na.rm=TRUE)
}
#calc means and sdevs for mrpc (remove method and inf columns)
x.mean.mrpc[i,1]=x[i]
if(length(which(params[,which.param]==x[i]))==1){
x.mean.mrpc[i,2:5]=x.mrpc[which(params[,which.param]==x[i]),-c(1:3)]
x.mean.mrpc[i,6:9]=rep(NA, 4)
}else{
x.mean.mrpc[i,2:5]=apply(x.mrpc[which(params[,which.param]==x[i]),-c(1:3)], 2, mean, na.rm=TRUE)
x.mean.mrpc[i,6:9]=apply(x.mrpc[which(params[,which.param]==x[i]),-c(1:3)], 2, sd, na.rm=TRUE)
}
}
#bind for plotting
all.means.x=rbind.data.frame(cbind.data.frame(Method=rep("MRGN", length(x)), x.mean.mrgn),
cbind.data.frame(Method=rep("MRPC", length(x)), x.mean.mrpc))
return(all.means.x)
}
##############################################
plot.spline=function(Data=NULL, pd=NULL, spline.int=NULL, params=NULL, which.param=NULL, rplot=4, nplot=1){
#precision
A=ggplot(data=Data, aes(x=param.value, y=precision, color=Method))+
geom_line(position = pd)+
geom_point(position = pd)+
stat_smooth(n=spline.int)+
xlab(paste0(colnames(params)[which.param]))+
ylab("Mean Precision")
#Recall
B=ggplot(data=Data, aes(x=param.value, y=recall, color=Method))+
geom_line(position = pd)+
geom_point(position = pd)+
stat_smooth(n=spline.int)+
xlab(paste0(colnames(params)[which.param]))+
ylab("Mean Recall")
#Specificity
C=ggplot(data=Data, aes(x=param.value, y=specificity, color=Method))+
geom_line(position = pd)+
geom_point(position = pd)+
stat_smooth(n=spline.int)+
xlab(paste0(colnames(params)[which.param]))+
ylab("Mean Specificity")
#F1
D=ggplot(data=Data, aes(x=param.value, y=FOR, color=Method))+
geom_line(position = pd)+
geom_point(position = pd)+
stat_smooth(n=spline.int)+
xlab(paste0(colnames(params)[which.param]))+
ylab("Mean FOR")
#Combine
Z=ggarrange(A,B,C,D, labels=c("A","B","C","D"), nrow=rplot, ncol=nplot)
plot(Z)
}
##############################################
plot.regular=function(Data=NULL, pd=NULL, params=NULL, which.param=NULL, rplot=4, nplot=1){
#Precision
A=ggplot(data=Data, aes(x=param.value, y=precision, color=Method))+
geom_line(position = pd)+
geom_point(position = pd)+
xlab(paste0(colnames(params)[which.param]))+
ylab("Mean Precision")
#Recall
B=ggplot(data=Data, aes(x=param.value, y=recall, color=Method))+
geom_line(position = pd)+
geom_point(position = pd)+
xlab(paste0(colnames(params)[which.param]))+
ylab("Mean Recall")
#Specificity
C=ggplot(data=Data, aes(x=param.value, y=specificity, color=Method))+
geom_line(position = pd)+
geom_point(position = pd)+
xlab(paste0(colnames(params)[which.param]))+
ylab("Mean Specificity")
#F1
D=ggplot(data=Data, aes(x=param.value, y=FOR, color=Method))+
geom_line(position = pd)+
geom_point(position = pd)+
xlab(paste0(colnames(params)[which.param]))+
ylab("Mean FOR")
#Combine
Z=ggarrange(A,B,C,D, labels=c("A","B","C","D"), nrow=rplot, ncol=nplot)
plot(Z)
}
##############################################
plot.sim.metrics=function(metrics.mrgn=NULL, metrics.mrpc=NULL, params=NULL, which.param=2, by.class=FALSE,
which.class=NULL, plot.it=TRUE, spline.it=TRUE, spline.int=10, dodge=0.1,
return.means=TRUE, rplot=4, nplot=1, save.plot=FALSE, plot.path=""){
library(ggpubr)
pd=position_dodge(dodge)
if(by.class==TRUE){
#calc averages within a certain model class
metrics.mrgn.m=subset(metrics.mrgn, truth==which.class)
metrics.mrpc.m=subset(metrics.mrpc, truth==which.class)
#get mean scores across parameter within class
avg.scores.all=get.avg(x.mrgn = metrics.mrgn.m,
x.mrpc = metrics.mrpc.m,
params = params,
which.param = which.param)
}else{
#get mean scores across parameter
avg.scores.all=get.avg(x.mrgn = metrics.mrgn,
x.mrpc = metrics.mrpc,
params = params,
which.param = which.param)
}
#plotting - splined plots
if(plot.it==TRUE & spline.it==TRUE){
#for plot saving
if(save.plot==TRUE){
png(plot.path)
plot.spline(avg.scores.all,
pd = pd,
spline.int = spline.int,
params = params,
which.param = which.param,
rplot = rplot,
nplot = nplot)
dev.off()
}else{
plot.spline(avg.scores.all,
pd = pd,
spline.int = spline.int,
params = params,
which.param = which.param,
rplot = rplot,
nplot = nplot)
}
#plotting - regular plots
}else if(plot.it==TRUE & spline.it==FALSE){
if(save.plot==TRUE){
png(plot.path)
plot.regular(Data = avg.scores.all,
pd = pd,
params = params,
which.param = which.param,
rplot = rplot,
nplot = nplot)
dev.off()
}else{
plot.regular(Data = avg.scores.all,
pd = pd,
params = params,
which.param = which.param,
rplot = rplot,
nplot = nplot)
}
}
#return mean score and sdev data
if(return.means==TRUE){
return(avg.scores.all)
}
}
small.datasets.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrgn_1k_datasets_wpc2small.RData")
small.reg.res.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrgn_1k_regres_results_wpc2small.RData")
small.inf.mods.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrgn_1k_inf_results_wpc2small.RData")
small.mrpc.inf.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrpc_1k_small_results_wpc2small.RData")
small.params.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrpc_v_mrgn_1k_params_wpc2small.RData")
small.mrpc.inf=lapply(small.mrpc.inf.wpc, function(x,i) x[[i]], i=1)
small.mrpc.adj=lapply(small.mrpc.inf.wpc, function(x,i) x[[i]], i=2)
model.truth.sm=convert.truth(small.params.wpc$model)
small.inf.cats=convert.cats(small.inf.mods.wpc)
small.mrpc.inf.cats=convert.cats(unlist(small.mrpc.inf))
kable(table(Truth=model.truth.sm, Inferred=small.inf.cats), caption = "Confusion matrix showing the performance of MRGN in inferring models M0 and M1 in the presence of confounding variables in scenario 2")
kable(table(Truth=model.truth.sm, Inferred=small.mrpc.inf.cats), caption = "Confusion matrix showing the performance of MRPC in inferring models M0 and M1 in the presence of confounding variables scenario 2")
small.mrgn.metrics.wpc=as.data.frame(matrix(0, nrow = 1000, ncol = 4))
small.mrpc.metrics.wpc=as.data.frame(matrix(0, nrow = 1000, ncol = 4))
colnames(small.mrgn.metrics.wpc)=c("prec_edge", "recall", "specificity", "FOR")
colnames(small.mrpc.metrics.wpc)=c("prec_edge", "recall", "specificity", "FOR")
for(i in 1:1000){
small.mrgn.metrics.wpc[i,]=get.metrics(Truth = model.truth.sm[i],
Inferred = small.inf.cats[i], get.adj.inf = TRUE)
small.mrpc.metrics.wpc[i,]=get.metrics(Truth = model.truth.sm[i],
Inferred = small.mrpc.inf.cats[i], get.adj.inf = TRUE)
}
small.mrgn.metrics.wpc=cbind.data.frame(Method=rep("MRGN",1000), truth=model.truth.sm, inf=small.inf.cats,
small.mrgn.metrics.wpc)
small.mrpc.metrics.wpc=cbind.data.frame(Method=rep("MRPC",1000), truth=model.truth.sm, inf=small.mrpc.inf.cats,
small.mrpc.metrics.wpc)
#calculate performance across confounders
# num.conf=unique(small.params.wpc$number.of.conf)
# mean.met.conf.mrgn=as.data.frame(matrix(0, nrow = length(num.conf), ncol = 4))
# mean.met.conf.mrpc=as.data.frame(matrix(0, nrow = length(num.conf), ncol = 4))
# for(i in 1:length(num.conf)){
#
# }
plot.sim.metrics(metrics.mrgn=small.mrgn.metrics.wpc,
metrics.mrpc=small.mrpc.metrics.wpc,
params=small.params.wpc,
which.param=6,
by.class=FALSE,
which.class=NULL,
plot.it=TRUE,
spline.it=TRUE,
spline.int=15,
dodge=0.1,
return.means=FALSE,
rplot=4,
nplot=1,
save.plot=FALSE,
plot.path="")
length(unique(small.params.wpc))
small.datasets.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrgn_1k_datasets_wpc2small.RData")
small.reg.res.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrgn_1k_regres_results_wpc2small.RData")
small.inf.mods.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrgn_1k_inf_results_wpc2small.RData")
small.mrpc.inf.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrpc_1k_small_results_wpc2small.RData")
small.params.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrpc_v_mrgn_1k_params_wpc2small.RData")
small.mrpc.inf=lapply(small.mrpc.inf.wpc, function(x,i) x[[i]], i=1)
small.mrpc.adj=lapply(small.mrpc.inf.wpc, function(x,i) x[[i]], i=2)
model.truth.sm=convert.truth(small.params.wpc$model)
small.inf.cats=convert.cats(small.inf.mods.wpc)
small.mrpc.inf.cats=convert.cats(unlist(small.mrpc.inf))
kable(table(Truth=model.truth.sm, Inferred=small.inf.cats), caption = "Confusion matrix showing the performance of MRGN in inferring models M0 and M1 in the presence of confounding variables in scenario 2")
kable(table(Truth=model.truth.sm, Inferred=small.mrpc.inf.cats), caption = "Confusion matrix showing the performance of MRPC in inferring models M0 and M1 in the presence of confounding variables scenario 2")
small.mrgn.metrics.wpc=as.data.frame(matrix(0, nrow = 1000, ncol = 4))
small.mrpc.metrics.wpc=as.data.frame(matrix(0, nrow = 1000, ncol = 4))
colnames(small.mrgn.metrics.wpc)=c("prec_edge", "recall", "specificity", "FOR")
colnames(small.mrpc.metrics.wpc)=c("prec_edge", "recall", "specificity", "FOR")
for(i in 1:1000){
small.mrgn.metrics.wpc[i,]=get.metrics(Truth = model.truth.sm[i],
Inferred = small.inf.cats[i], get.adj.inf = TRUE)
small.mrpc.metrics.wpc[i,]=get.metrics(Truth = model.truth.sm[i],
Inferred = small.mrpc.inf.cats[i], get.adj.inf = TRUE)
}
small.mrgn.metrics.wpc=cbind.data.frame(Method=rep("MRGN",1000), truth=model.truth.sm, inf=small.inf.cats,
small.mrgn.metrics.wpc)
small.mrpc.metrics.wpc=cbind.data.frame(Method=rep("MRPC",1000), truth=model.truth.sm, inf=small.mrpc.inf.cats,
small.mrpc.metrics.wpc)
#calculate performance across confounders
# num.conf=unique(small.params.wpc$number.of.conf)
# mean.met.conf.mrgn=as.data.frame(matrix(0, nrow = length(num.conf), ncol = 4))
# mean.met.conf.mrpc=as.data.frame(matrix(0, nrow = length(num.conf), ncol = 4))
# for(i in 1:length(num.conf)){
#
# }
plot.sim.metrics(metrics.mrgn=small.mrgn.metrics.wpc,
metrics.mrpc=small.mrpc.metrics.wpc,
params=small.params.wpc,
which.param=6,
by.class=FALSE,
which.class=NULL,
plot.it=TRUE,
spline.it=TRUE,
spline.int=2,
dodge=0.1,
return.means=FALSE,
rplot=4,
nplot=1,
save.plot=FALSE,
plot.path="")
small.mrpc.metrics.wpc
colMeans(small.mrpc.metrics.wpc)
colMeans(small.mrpc.metrics.wpc[,-c(1:3)])
colMeans(small.mrgn.metrics.wpc[,-c(1:3)])
library(devtools)
getwd()
devtools::uninstall()
document()
devtools::install()
devtools::uninstall()
document
document()
devtools::install()
devtools::uninstall()
