metrics.mrpc=mrpc.metrics,
params=params,
type="Edge",
which.model="M1",
which.param=4,
plot.ci=FALSE,
# spline.it = TRUE,
# spline.interval = 10,
# spline.type = "natural",
return.x = TRUE)
M1.sd=plot.sim.metrics(metrics.mrgn=mrgn.metrics,
metrics.mrpc=mrpc.metrics,
params=params,
type="Edge",
which.model="M1",
which.param=3,
plot.ci=FALSE,
# spline.it = TRUE,
# spline.interval = 10,
# spline.type = "natural",
return.x = TRUE)
M1.b1=plot.sim.metrics(metrics.mrgn=mrgn.metrics,
metrics.mrpc=mrpc.metrics,
params=params,
type="Edge",
which.model="M1",
which.param=5,
plot.ci=FALSE,
return.x = TRUE)
M1.all=list(signal=M1.b1, minor.freq=M1.mf, noise=M1.sd, sample.size=M1.ss)
P=list()
pd <- position_dodge(0.05)
for(i in 1:length(M1.all)){
P[[i]]=ggplot(data=M1.all[[i]], aes(x=param.value, y=mean.recall, colour=method))+
#geom_errorbar(aes(ymin=mean.recall-ci.recall, ymax=mean.recall+ci.recall), position=pd) +
geom_point(position=pd) +
stat_smooth(n=10) +
#geom_line(position=pd) +
geom_point(position=pd) +
xlab(paste0(names(M1.all)[i]))+
ylab("Mean Recall")
}
ggarrange(P[[1]],P[[2]],P[[3]],P[[4]], labels=c("A","B","C","D"),nrow=2,ncol=2)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.width=12, fig.height=8)
M1.ss=plot.sim.metrics(metrics.mrgn=mrgn.metrics,
metrics.mrpc=mrpc.metrics,
params=params,
type="Edge",
which.model="M1",
which.param=2,
plot.ci=FALSE,
return.x = TRUE)
M1.mf=plot.sim.metrics(metrics.mrgn=mrgn.metrics,
metrics.mrpc=mrpc.metrics,
params=params,
type="Edge",
which.model="M1",
which.param=4,
plot.ci=FALSE,
# spline.it = TRUE,
# spline.interval = 10,
# spline.type = "natural",
return.x = TRUE)
M1.sd=plot.sim.metrics(metrics.mrgn=mrgn.metrics,
metrics.mrpc=mrpc.metrics,
params=params,
type="Edge",
which.model="M1",
which.param=3,
plot.ci=FALSE,
# spline.it = TRUE,
# spline.interval = 10,
# spline.type = "natural",
return.x = TRUE)
M1.b1=plot.sim.metrics(metrics.mrgn=mrgn.metrics,
metrics.mrpc=mrpc.metrics,
params=params,
type="Edge",
which.model="M1",
which.param=5,
plot.ci=FALSE,
return.x = TRUE)
M1.all=list(signal=M1.b1, minor.freq=M1.mf, noise=M1.sd, sample.size=M1.ss)
P=list()
pd <- position_dodge(0.05)
for(i in 1:length(M1.all)){
P[[i]]=ggplot(data=M1.all[[i]], aes(x=param.value, y=mean.recall, colour=method))+
#geom_errorbar(aes(ymin=mean.recall-ci.recall, ymax=mean.recall+ci.recall), position=pd) +
geom_point(position=pd) +
stat_smooth(n=10) +
#geom_line(position=pd) +
geom_point(position=pd) +
xlab(paste0(names(M1.all)[i]))+
ylab("Mean Recall")
}
ggarrange(P[[1]],P[[2]],P[[3]],P[[4]], labels=c("A","B","C","D"),nrow=2,ncol=2)
M1.ss=plot.sim.metrics(metrics.mrgn=mrgn.metrics,
metrics.mrpc=mrpc.metrics,
params=params,
type="Edge",
which.model="M1",
which.param=2,
plot.ci=FALSE,
return.x = TRUE)
M1.mf=plot.sim.metrics(metrics.mrgn=mrgn.metrics,
metrics.mrpc=mrpc.metrics,
params=params,
type="Edge",
which.model="M1",
which.param=4,
plot.ci=FALSE,
# spline.it = TRUE,
# spline.interval = 10,
# spline.type = "natural",
return.x = TRUE)
M1.sd=plot.sim.metrics(metrics.mrgn=mrgn.metrics,
metrics.mrpc=mrpc.metrics,
params=params,
type="Edge",
which.model="M1",
which.param=3,
plot.ci=FALSE,
# spline.it = TRUE,
# spline.interval = 10,
# spline.type = "natural",
return.x = TRUE)
M1.b1=plot.sim.metrics(metrics.mrgn=mrgn.metrics,
metrics.mrpc=mrpc.metrics,
params=params,
type="Edge",
which.model="M1",
which.param=5,
plot.ci=FALSE,
return.x = TRUE)
M1.all=list(signal=M1.b1, minor.freq=M1.mf, noise=M1.sd, sample.size=M1.ss)
P=list()
pd <- position_dodge(0.05)
for(i in 1:length(M1.all)){
P[[i]]=ggplot(data=M1.all[[i]], aes(x=mean.prec, y=mean.recall, colour=method))+
#geom_errorbar(aes(ymin=mean.recall-ci.recall, ymax=mean.recall+ci.recall), position=pd) +
geom_point(position=pd) +
stat_smooth(n=10) +
#geom_line(position=pd) +
geom_point(position=pd)
#xlab(paste0(names(M1.all)[i]))+
#ylab("Mean Recall")
}
ggarrange(P[[1]],P[[2]],P[[3]],P[[4]], labels=c("A","B","C","D"),nrow=2,ncol=2)
M1.all[[1]]
source("C:/Users/Bruin/Documents/GitHub/MRGN/mrgn_triospecific.R")
library(knitr)
library(ggplot2)
library(ggpubr)
#load in triospecific script
#source("C:/Users/Bruin/Documents/GitHub/MRGN/mrgn_triospecific.R")
#load in mrnet v mrpc simulation data
load(file = "C:/Users/Bruin/Documents/GitHub/MRGN/Simulations/Sim_result_Data/mrgn_5000_regres_results.RData")
load(file = "C:/Users/Bruin/Documents/GitHub/MRGN/Simulations/Sim_result_Data/mrgn_5000_inf_results.RData")
load(file = "C:/Users/Bruin/Documents/GitHub/MRGN/Simulations/Sim_result_Data/mrpc_v_mrgn_5000_params.RData")
load(file = "C:/Users/Bruin/Documents/GitHub/MRGN/Simulations/Sim_result_Data/mrpc_5000_results.RData")
load(file = "C:/Users/Bruin/Documents/GitHub/MRGN/Simulations/Sim_result_Data/mrgn_5000_datasets.RData")
mrpc.inf=lapply(mrpc.infer, function(x,i) x[[i]], i=1)
mrpc.adj=lapply(mrpc.infer, function(x,i) x[[i]], i=2)
which.null=unlist(lapply(mrpc.inf, is.null))
mrpc.inf[which.null]="Other"
mrpc.inf=unlist(mrpc.inf)
truth.converted=convert.actual(params$model)
#remember trio 406 is strange--> classed as other but all regression coefficients are significant
t1=table(Actual=convert.actual(params$model), MRGN=inf.mods)
t11=table(Actual=convert.actual(params$model), MRGN=convert.cats(inf.mods))
#print(t1)
#print(sum(diag(t1))/sum(colSums(t1)))
t2=table(Actual=convert.actual(params$model), MRPC=mrpc.inf)
t22=table(Actual=convert.actual(params$model), MRPC=convert.cats(mrpc.inf))
#print(t2)
#print(sum(diag(t2))/sum(colSums(t2)))
#MRGN
kable(t1, caption = "Confusion matrix comparing the true class labels (rows) to the class labels inferred by MRGN (columns) without merged subclasses")
kable(t11, caption = "Confusion matrix comparing the true class labels (rows) to the class labels inferred by MRGN (columns) with merged subclasses")
print(paste0("MRGN all class combined accuracy = ", sum(diag(t11))/sum(colSums(t11))))
kable(t2, caption = "Confusion matrix comparing the true class labels (rows) to the class labels inferred by MRPC (columns) without merged subclasses")
kable(t22, caption = "Confusion matrix comparing the true model types (rows) to the model types inferred by MRPC (columns) with merged subclasses")
print(paste0("MRPC all class combined accuracy = ", sum(diag(t22))/sum(colSums(t22))))
#using caret to get class label metrics
library(caret)
mrgn.class=convert.cats(inf.mods[-which(inf.mods=="Other")])
mrpc.class=convert.cats(mrpc.inf[-which(mrpc.inf=="Other")])
c1=confusionMatrix(as.factor(mrgn.class), as.factor(truth.converted[-which(inf.mods=="Other")]))
c2=confusionMatrix(as.factor(mrpc.class), as.factor(truth.converted[-which(mrpc.inf=="Other")]))
met.table=cbind.data.frame(rbind.data.frame(model=rep("MRGN",5),round(t(c1$byClass),3)),
rbind.data.frame(model=rep("MRPC",5),round(t(c2$byClass),3)))
kable(met.table, caption = "The within-class performance metrics comparing MRGN and MRPC inferred model labels to true model label - results obtained from confusionMatrix() in the caret package and excludes trios classified as \"Other\" ", digits = 3)
mrgn.metrics=as.data.frame(matrix(0, nrow = 10000, ncol = 4))
mrpc.metrics=as.data.frame(matrix(0, nrow = 10000, ncol = 4))
colnames(mrgn.metrics)=c("prec_edge", "recall", "specificity", "f1_score")
colnames(mrpc.metrics)=c("prec_edge", "recall", "specificity", "f1_score")
for(i in 1:10000){
mrgn.metrics[i,]=get.metrics(Truth = truth.converted[i], Inferred = inf.mods[i], reg.vec=reg.res[1:4,i])
mrpc.metrics[i,]=get.metrics(Truth = truth.converted[i], Inferred = mrpc.adj[[i]], get.adj.inf = TRUE)
}
mrgn.metrics=cbind.data.frame(Method=rep("MRGN",10000), inf=convert.cats(inf.mods), mrgn.metrics)
mrpc.metrics=cbind.data.frame(Method=rep("MRPC",10000), inf=convert.cats(mrpc.inf), mrpc.metrics)
####################################################
#A function to smooth the graph based on the splining interval specified in get.avg()
get.smooth=function(mean.mrgn=NULL, mean.mrpc=NULL, param=NULL, seq1=NULL, seq2=NULL){
#second preallocation
mrgn.mean.sm=as.data.frame(matrix(0, nrow = min(length(seq1),length(seq2)), ncol = 9))
mrpc.mean.sm=as.data.frame(matrix(0, nrow = min(length(seq1),length(seq2)), ncol = 9))
colnames(mrgn.mean.sm)=c("param.value","mean.prec","mean.recall","mean.specif","mean.f1",
"ci.prec","ci.recall","ci.specif","ci.f1")
colnames(mrpc.mean.sm)=c("param.value","mean.prec","mean.recall","mean.specif","mean.f1",
"ci.prec","ci.recall","ci.specif","ci.f1")
#get the number of iterations based on which seq is smaller
iter.length=min(length(seq1),length(seq2))
for(i in 1:iter.length){
#spline the mrgn and mrpc data
if(i==min(length(seq1),length(seq2))){
mrgn.mean.sm[i,1]=param[length(param)]
mrgn.mean.sm[i,2:9]=apply(mean.mrgn[seq1[i]:length(param),-1],2,mean)
mrpc.mean.sm[i,1]=param[length(param)]
mrpc.mean.sm[i,2:9]=apply(mean.mrpc[seq1[i]:length(param),-1],2,mean)
}else{
mrgn.mean.sm[i,1]=param[seq2[i]]
mrgn.mean.sm[i,2:9]=apply(mean.mrgn[seq1[i]:seq2[i],-1],2,mean)
mrpc.mean.sm[i,1]=param[seq2[i]]
mrpc.mean.sm[i,2:9]=apply(mean.mrpc[seq1[i]:seq2[i],-1],2,mean)
}
}
#return
return(list(sm.mrgn=mrgn.mean.sm,sm.mrpc=mrpc.mean.sm))
}
####################################################
#a function to ge the average performance metrics for mrpc and mrgn
get.avg=function(x.mrgn=NULL,x.mrpc=NULL,params=NULL,which.param=2, spline.it=FALSE, spline.interval=10,
by.model=FALSE, which.model=NULL){
#get the sorted unique sim parameters
x=sort(unique(params[,which.param]))
#preallocate
mean.x.mrgn=as.data.frame(matrix(0, nrow = length(x), ncol = 9))
mean.x.mrpc=as.data.frame(matrix(0, nrow = length(x), ncol = 9))
colnames(mean.x.mrgn)=c("param.value","mean.prec","mean.recall","mean.specif","mean.f1",
"ci.prec","ci.recall","ci.specif","ci.f1")
colnames(mean.x.mrpc)=c("param.value","mean.prec","mean.recall","mean.specif","mean.f1",
"ci.prec","ci.recall","ci.specif","ci.f1")
if(by.model==TRUE){
true.mods=convert.actual(params$model)
#handle the per class scenario - extract data for class
x.mrgn.m=x.mrgn[which(true.mods==which.model),]
x.mrpc.m=x.mrpc[which(true.mods==which.model),]
params.mrgn=params[which(true.mods==which.model),]
params.mrpc=params[which(true.mods==which.model),]
#print(length(unique(params.mrgn[,which.param])))
#calculate the means
for(i in 1:length(x)){
#mrgn
mean.x.mrgn[i,1]=x[i]
mean.x.mrgn[i,2:5]=apply(x.mrgn.m[which(params.mrgn[,which.param]==x[i]),-c(1:2)],2,mean)
mean.x.mrgn[i,6:9]=apply(x.mrgn.m[which(params.mrgn[,which.param]==x[i]),-c(1:2)],2,
function(x){2*(sd(x)/sqrt(length(x)))})
#mrpc
mean.x.mrpc[i,1]=x[i]
mean.x.mrpc[i,2:5]=apply(x.mrpc.m[which(params.mrpc[,which.param]==x[i]),-c(1:2)],2,mean)
mean.x.mrpc[i,6:9]=apply(x.mrpc.m[which(params.mrpc[,which.param]==x[i]),-c(1:2)],2,
function(x){2*(sd(x)/sqrt(length(x)))})
}
}else{
#calculate the means
for(i in 1:length(x)){
#mrgn
mean.x.mrgn[i,1]=x[i]
mean.x.mrgn[i,2:5]=apply(x.mrgn[which(params[,which.param]==x[i]),-c(1:2)],2,mean)
mean.x.mrgn[i,6:9]=apply(x.mrgn[which(params[,which.param]==x[i]),-c(1:2)],2,
function(x){2*(sd(x)/sqrt(length(x)))})
#mrpc
mean.x.mrpc[i,1]=x[i]
mean.x.mrpc[i,2:5]=apply(x.mrpc[which(params[,which.param]==x[i]),-c(1:2)],2,mean)
mean.x.mrpc[i,6:9]=apply(x.mrpc[which(params[,which.param]==x[i]),-c(1:2)],2,
function(x){2*(sd(x)/sqrt(length(x)))})
}
}
#print(mean.x.mrgn)
#handling of spline option for smoothing
if(spline.it==TRUE){
#smoothing:
#get the smoothing intervals
seq.vals1=seq(1,length(x), spline.interval)
seq.vals2=seq(spline.interval,length(x), spline.interval)
#pass to get.smooth()
mean.sm=get.smooth(mean.mrgn = mean.x.mrgn,
mean.mrpc = mean.x.mrpc,
seq1 = seq.vals1,
seq2 = seq.vals2,
param = x)
#extract the smoothed values
mean.x.mrgn=mean.sm$sm.mrgn
mean.x.mrpc=mean.sm$sm.mrpc
}
#combine into big dataframe
metrics.comb=rbind.data.frame(cbind.data.frame(method=rep("MRGN",dim(mean.x.mrgn)[1]), mean.x.mrgn),
cbind.data.frame(method=rep("MRPC",dim(mean.x.mrpc)[1]), mean.x.mrpc))
return(metrics.comb)
}
####################################################
#a wrapper function to plot metrics from the simulations
plot.sim.metrics=function(metrics.mrgn=NULL, metrics.mrpc=NULL, True.class=NULL, Inf.class=NULL, params=NULL,
type=c("Class","Edge"), which.model=NULL, which.param=2, plot.ci=TRUE, dodge=0.1,
spline.it=FALSE, spline.interval=10, spline.type=c("natural", "ggplot"),
return.x=FALSE){
#load packages
library(caret)
library(ggplot2)
#class based prediction metrics
if(type=="Class"){
if(is.null(which.model)){
print(NULL)
}else{
print(NULL)
}
#edge based metrics
}else if(type=="Edge"){
if(is.null(which.model)){
#handle smoothing
if(spline.it==TRUE & spline.type=="natural"){
metrics.comb=get.avg(x.mrgn = metrics.mrgn,
x.mrpc = metrics.mrpc,
params = params,
which.param = which.param,
spline.it = spline.it,
spline.interval = spline.interval)
#handle other
}else{
metrics.comb=get.avg(x.mrgn = metrics.mrgn,
x.mrpc = metrics.mrpc,
params = params,
which.param = which.param)
}
}else{
#handle splining by average
if(spline.it==TRUE & spline.type=="natural"){
metrics.comb=get.avg(x.mrgn = metrics.mrgn,
x.mrpc = metrics.mrpc,
params = params,
which.param = which.param,
spline.it = spline.it,
spline.interval = spline.interval,
by.model=TRUE,
which.model=which.model)
}else{
metrics.comb=get.avg(x.mrgn = metrics.mrgn,
x.mrpc = metrics.mrpc,
params = params,
which.param = which.param,
by.model=TRUE,
which.model=which.model)
}
}
#close logicals
#plotting
if(plot.ci==TRUE){
pd <- position_dodge(dodge) # move them .05 to the left and right
#if spline.it is true and the desired method is via ggplot2
if(spline.it==TRUE & spline.type=="ggplot"){
A=ggplot(metrics.comb, aes(x=param.value, y=mean.prec, colour=method)) +
geom_point(position=pd) +
stat_smooth(n=spline.interval) +
xlab(paste0(colnames(params)[which.param]))+
ylab("Mean Precision")
B=ggplot(metrics.comb, aes(x=param.value, y=mean.recall, colour=method)) +
geom_point(position=pd) +
stat_smooth(n=spline.interval) +
xlab(paste0(colnames(params)[which.param])) +
ylab("Mean Recall")
C=ggplot(metrics.comb, aes(x=param.value, y=mean.specif, colour=method)) +
geom_point(position=pd) +
stat_smooth(n=spline.interval) +
xlab(paste0(colnames(params)[which.param])) +
ylab("Mean Specificity")
Z=ggarrange(A,B,C, labels=c("A","B","C"), nrow=3, ncol=1)
plot(Z)
#alternative case with no splining - includes confidence intervals
}else{
A=ggplot(metrics.comb, aes(x=param.value, y=mean.prec, colour=method)) +
geom_errorbar(aes(ymin=mean.prec-ci.prec, ymax=mean.prec+ci.prec), position=pd) +
geom_line(position=pd) +
geom_point(position=pd) +
xlab(paste0(colnames(params)[which.param]))+
ylab("Mean Precision")
B=ggplot(metrics.comb, aes(x=param.value, y=mean.recall, colour=method)) +
geom_errorbar(aes(ymin=mean.recall-ci.recall, ymax=mean.recall+ci.recall), position=pd) +
geom_line(position=pd) +
geom_point(position=pd) +
xlab(paste0(colnames(params)[which.param])) +
ylab("Mean Recall")
C=ggplot(metrics.comb, aes(x=param.value, y=mean.specif, colour=method)) +
geom_errorbar(aes(ymin=mean.specif-ci.specif, ymax=mean.specif+ci.specif), position=pd) +
geom_line(position=pd) +
geom_point(position=pd)+
xlab(paste0(colnames(params)[which.param])) +
ylab("Mean Specificity")
Z=ggarrange(A,B,C, labels=c("A","B","C"), nrow=3, ncol=1)
plot(Z)
}
}
}
#return the avg or avg+smooth metrics data frame
if(return.x==TRUE){return(metrics.comb)}
}
plot.sim.metrics(metrics.mrgn=mrgn.metrics,
metrics.mrpc=mrpc.metrics,
params=params,
type="Edge",
which.param=2,
dodge=0.2,
plot.ci=TRUE,
# spline.it = TRUE,
# spline.interval = 15,
# spline.type = "ggplot",
return.x=FALSE)
M1.ss=plot.sim.metrics(metrics.mrgn=mrgn.metrics,
metrics.mrpc=mrpc.metrics,
params=params,
type="Edge",
which.model="M1",
which.param=2,
plot.ci=FALSE,
return.x = TRUE)
M1.mf=plot.sim.metrics(metrics.mrgn=mrgn.metrics,
metrics.mrpc=mrpc.metrics,
params=params,
type="Edge",
which.model="M1",
which.param=4,
plot.ci=FALSE,
# spline.it = TRUE,
# spline.interval = 10,
# spline.type = "natural",
return.x = TRUE)
M1.sd=plot.sim.metrics(metrics.mrgn=mrgn.metrics,
metrics.mrpc=mrpc.metrics,
params=params,
type="Edge",
which.model="M1",
which.param=3,
plot.ci=FALSE,
# spline.it = TRUE,
# spline.interval = 10,
# spline.type = "natural",
return.x = TRUE)
M1.b1=plot.sim.metrics(metrics.mrgn=mrgn.metrics,
metrics.mrpc=mrpc.metrics,
params=params,
type="Edge",
which.model="M1",
which.param=5,
plot.ci=FALSE,
return.x = TRUE)
M1.all=list(signal=M1.b1, minor.freq=M1.mf, noise=M1.sd, sample.size=M1.ss)
P=list()
pd <- position_dodge(0.05)
for(i in 1:length(M1.all)){
P[[i]]=ggplot(data=M1.all[[i]], aes(x=mean.recall, y=mean.prec, colour=method))+
#geom_errorbar(aes(ymin=mean.recall-ci.recall, ymax=mean.recall+ci.recall), position=pd) +
geom_point(position=pd) +
stat_smooth(n=10) +
#geom_line(position=pd) +
geom_point(position=pd)
#xlab(paste0(names(M1.all)[i]))+
#ylab("Mean Recall")
}
ggarrange(P[[1]],P[[2]],P[[3]],P[[4]], labels=c("A","B","C","D"),nrow=2,ncol=2)
M1.all[[4]]
all.data=rbind.data.frame(mrgn.metrics,mrpc.metrics)
head(all.data)
ggplot(data=M1.all[[i]], aes(x=recall, y=prec_edge, colour=Method))+
#geom_errorbar(aes(ymin=mean.recall-ci.recall, ymax=mean.recall+ci.recall), position=pd) +
geom_point(position=pd) +
stat_smooth(n=10) +
#geom_line(position=pd) +
geom_point(position=pd)
colnames(all.data)
ggplot(data=all.data, aes(x=recall, y=prec_edge, colour=Method))+
#geom_errorbar(aes(ymin=mean.recall-ci.recall, ymax=mean.recall+ci.recall), position=pd) +
geom_point(position=pd) +
stat_smooth(n=10) +
#geom_line(position=pd) +
geom_point(position=pd)
ggplot(data=all.data, aes(x=recall, y=prec_edge, colour=Method))+
#geom_errorbar(aes(ymin=mean.recall-ci.recall, ymax=mean.recall+ci.recall), position=pd) +
geom_point(position = 0.01) +
stat_smooth(n=10) +
#geom_line(position=pd) +
geom_point(position= 0.01)
ggplot(data=all.data, aes(x=recall, y=prec_edge, colour=Method))+
#geom_errorbar(aes(ymin=mean.recall-ci.recall, ymax=mean.recall+ci.recall), position=pd) +
geom_point(position=pd) +
stat_smooth(n=10) +
#geom_line(position=pd) +
geom_point(position=pd)
head(all.data)
head(mrpc.metrics)
dim(mrpc.metrics)
summary(mrpc.metrics[,-c(1:2)])
summary(mrgn.metrics[,-c(1:2)])
library(devtools)
library(roxygen2)
setwd("C:/Users/Bruin/Documents/GitHub")
create("MRGN")
setwd("C:/Users/Bruin/Documents/GitHub/MRGN")
document()
?manova
document()
