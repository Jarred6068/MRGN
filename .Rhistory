brks1 = seq(0,1.1,0.1),
save.plot=FALSE,
plot.path="")
small.datasets.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrgn_1k_datasets_wpc2small.RData")
small.reg.res.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrgn_1k_regres_results_wpc2small.RData")
small.inf.mods.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrgn_1k_inf_results_wpc2small.RData")
small.mrpc.inf.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrpc_1k_small_results_wpc2small.RData")
small.params.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrpc_v_mrgn_1k_params_wpc2small.RData")
small.mrpc.inf=lapply(small.mrpc.inf.wpc, function(x,i) x[[i]], i=1)
small.mrpc.adj=lapply(small.mrpc.inf.wpc, function(x,i) x[[i]], i=2)
model.truth.sm=convert.truth(small.params.wpc$model)
small.inf.cats=convert.cats(small.inf.mods.wpc)
small.mrpc.inf.cats=convert.cats(unlist(small.mrpc.inf))
kable(table(Truth=model.truth.sm, Inferred=small.inf.cats), caption = "Confusion matrix showing the performance of MRGN in inferring models M0 and M1 in the presence of confounding variables in scenario 2")
kable(table(Truth=model.truth.sm, Inferred=small.mrpc.inf.cats), caption = "Confusion matrix showing the performance of MRPC in inferring models M0 and M1 in the presence of confounding variables scenario 2")
small.mrgn.metrics.wpc=as.data.frame(matrix(0, nrow = 1000, ncol = 4))
small.mrpc.metrics.wpc=as.data.frame(matrix(0, nrow = 1000, ncol = 4))
colnames(small.mrgn.metrics.wpc)=c("prec_edge", "recall", "specificity", "FOR")
colnames(small.mrpc.metrics.wpc)=c("prec_edge", "recall", "specificity", "FOR")
for(i in 1:1000){
small.mrgn.metrics.wpc[i,]=get.metrics(Truth = model.truth.sm[i],
Inferred = small.inf.mods.wpc[i],
reg.vec = small.reg.res.wpc[,i],
get.adj.inf = TRUE,
get.adj.truth = TRUE)
small.mrpc.metrics.wpc[i,]=get.metrics(Truth = model.truth.sm[i],
Inferred = small.mrpc.adj[[i]],
get.adj.inf = FALSE,
get.adj.truth = TRUE)
}
X=cbind.data.frame(MRGN=colMeans(small.mrgn.metrics.wpc, na.rm = TRUE), MRPC=colMeans(small.mrpc.metrics.wpc, na.rm = TRUE))
X2=rbind.data.frame(X, c(median(small.params.wpc[,7]), median(small.params.wpc[,8])),
c(max(small.params.wpc$Time.to.compute.mrgn), max(small.params.wpc$Time.to.compute.mrpc)))
row.names(X2)=c("Precision","Recall","Specificity","False Omission Rate", "Median Comp Time (min)", "Max Comp Time (min)")
kable(X2,
caption = "Overall Edge-based inference performance of MRGN and MRPC on 1000 simulated trios with confounders from scenario 2 and average trio computation times", digits = 5)
small.mrgn.metrics.wpc=cbind.data.frame(Method=rep("MRGN",1000), truth=model.truth.sm, inf=small.inf.cats,
small.mrgn.metrics.wpc)
small.mrpc.metrics.wpc=cbind.data.frame(Method=rep("MRPC",1000), truth=model.truth.sm, inf=small.mrpc.inf.cats,
small.mrpc.metrics.wpc)
#calculate performance across confounders
# num.conf=unique(small.params.wpc$number.of.conf)
# mean.met.conf.mrgn=as.data.frame(matrix(0, nrow = length(num.conf), ncol = 4))
# mean.met.conf.mrpc=as.data.frame(matrix(0, nrow = length(num.conf), ncol = 4))
# for(i in 1:length(num.conf)){
#
# }
plot.sim.metrics(metrics.mrgn=small.mrgn.metrics.wpc,
metrics.mrpc=small.mrpc.metrics.wpc,
params=small.params.wpc,
which.param=6,
by.class=FALSE,
which.class=NULL,
plot.it=TRUE,
spline.it=TRUE,
spline.int=5,
dodge=0.1,
return.means=FALSE,
rplot=2,
nplot=1,
brks1 = seq(0,1.1,0.1),
save.plot=FALSE,
plot.path="")
.02*60
0.00016/0.02139
0.02139/0.00016
small.datasets.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrgn_1k_datasets_wpc2small.RData")
small.reg.res.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrgn_1k_regres_results_wpc2small.RData")
small.inf.mods.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrgn_1k_inf_results_wpc2small.RData")
small.mrpc.inf.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrpc_1k_small_results_wpc2small.RData")
small.params.wpc=loadRData(fileName = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Sim_wPC_result_data/mrpc_v_mrgn_1k_params_wpc2small.RData")
small.mrpc.inf=lapply(small.mrpc.inf.wpc, function(x,i) x[[i]], i=1)
small.mrpc.adj=lapply(small.mrpc.inf.wpc, function(x,i) x[[i]], i=2)
model.truth.sm=convert.truth(small.params.wpc$model)
small.inf.cats=convert.cats(small.inf.mods.wpc)
small.mrpc.inf.cats=convert.cats(unlist(small.mrpc.inf))
kable(table(Truth=model.truth.sm, Inferred=small.inf.cats), caption = "Confusion matrix showing the performance of MRGN in inferring models M0 and M1 in the presence of confounding variables in scenario 2")
kable(table(Truth=model.truth.sm, Inferred=small.mrpc.inf.cats), caption = "Confusion matrix showing the performance of MRPC in inferring models M0 and M1 in the presence of confounding variables scenario 2")
small.mrgn.metrics.wpc=as.data.frame(matrix(0, nrow = 1000, ncol = 4))
small.mrpc.metrics.wpc=as.data.frame(matrix(0, nrow = 1000, ncol = 4))
colnames(small.mrgn.metrics.wpc)=c("prec_edge", "recall", "specificity", "FOR")
colnames(small.mrpc.metrics.wpc)=c("prec_edge", "recall", "specificity", "FOR")
for(i in 1:1000){
small.mrgn.metrics.wpc[i,]=get.metrics(Truth = model.truth.sm[i],
Inferred = small.inf.mods.wpc[i],
reg.vec = small.reg.res.wpc[,i],
get.adj.inf = TRUE,
get.adj.truth = TRUE)
small.mrpc.metrics.wpc[i,]=get.metrics(Truth = model.truth.sm[i],
Inferred = small.mrpc.adj[[i]],
get.adj.inf = FALSE,
get.adj.truth = TRUE)
}
X=cbind.data.frame(MRGN=colMeans(small.mrgn.metrics.wpc, na.rm = TRUE), MRPC=colMeans(small.mrpc.metrics.wpc, na.rm = TRUE))
X2=rbind.data.frame(X, c(median(small.params.wpc[,7]), median(small.params.wpc[,8])),
c(max(small.params.wpc$Time.to.compute.mrgn), max(small.params.wpc$Time.to.compute.mrpc)))
row.names(X2)=c("Precision","Recall","Specificity","False Omission Rate", "Median Comp Time (min)", "Max Comp Time (min)")
kable(X2,
caption = "Overall edge-based performance and trio computation times for MRGN and MRPC on 1000 simulated M1 and M2 trios with confounders ", digits = 5)
small.mrgn.metrics.wpc=cbind.data.frame(Method=rep("MRGN",1000), truth=model.truth.sm, inf=small.inf.cats,
small.mrgn.metrics.wpc)
small.mrpc.metrics.wpc=cbind.data.frame(Method=rep("MRPC",1000), truth=model.truth.sm, inf=small.mrpc.inf.cats,
small.mrpc.metrics.wpc)
#calculate performance across confounders
# num.conf=unique(small.params.wpc$number.of.conf)
# mean.met.conf.mrgn=as.data.frame(matrix(0, nrow = length(num.conf), ncol = 4))
# mean.met.conf.mrpc=as.data.frame(matrix(0, nrow = length(num.conf), ncol = 4))
# for(i in 1:length(num.conf)){
#
# }
plot.sim.metrics(metrics.mrgn=small.mrgn.metrics.wpc,
metrics.mrpc=small.mrpc.metrics.wpc,
params=small.params.wpc,
which.param=6,
by.class=FALSE,
which.class=NULL,
plot.it=TRUE,
spline.it=TRUE,
spline.int=5,
dodge=0.1,
return.means=FALSE,
rplot=2,
nplot=1,
brks1 = seq(0.9,1.1,0.01),
save.plot=FALSE,
plot.path="")
library(devtools)
?install()
##############################################
get.avg=function(x.mrgn=NULL, x.mrpc=NULL, params=NULL, which.param=2){
#sort unique simulation parameter values
x=sort(unique(params[,which.param]))
#preallocate
x.mean.mrgn=as.data.frame(matrix(0, nrow = length(x), ncol = 9))
x.mean.mrpc=as.data.frame(matrix(0, nrow = length(x), ncol = 9))
colnames(x.mean.mrgn)=c("param.value","precision","recall","specificity","FOR", "se.prec",
"se.recall","se.specif","se_FOR")
colnames(x.mean.mrpc)=c("param.value","precision","recall","specificity","FOR", "se.prec",
"se.recall","se.specif","se_FOR")
#calculate mean across signal values
for(i in 1:length(x)){
#calc means and sdevs for mrgn (remove method and inf columns)
x.mean.mrgn[i,1]=x[i]
if(length(which(params[,which.param]==x[i]))==1){
x.mean.mrgn[i,2:5]=x.mrgn[which(params[,which.param]==x[i]),-c(1:3)]
x.mean.mrgn[i,6:9]=rep(NA, 4)
}else{
x.mean.mrgn[i,2:5]=apply(x.mrgn[which(params[,which.param]==x[i]),-c(1:3)], 2, mean, na.rm=TRUE)
x.mean.mrgn[i,6:9]=apply(x.mrgn[which(params[,which.param]==x[i]),-c(1:3)], 2, sd, na.rm=TRUE)
}
#calc means and sdevs for mrpc (remove method and inf columns)
x.mean.mrpc[i,1]=x[i]
if(length(which(params[,which.param]==x[i]))==1){
x.mean.mrpc[i,2:5]=x.mrpc[which(params[,which.param]==x[i]),-c(1:3)]
x.mean.mrpc[i,6:9]=rep(NA, 4)
}else{
x.mean.mrpc[i,2:5]=apply(x.mrpc[which(params[,which.param]==x[i]),-c(1:3)], 2, mean, na.rm=TRUE)
x.mean.mrpc[i,6:9]=apply(x.mrpc[which(params[,which.param]==x[i]),-c(1:3)], 2, sd, na.rm=TRUE)
}
}
#bind for plotting
all.means.x=rbind.data.frame(cbind.data.frame(Method=rep("MRGN", length(x)), x.mean.mrgn),
cbind.data.frame(Method=rep("MRPC", length(x)), x.mean.mrpc))
return(all.means.x)
}
##############################################
plot.spline=function(Data=NULL, pd=NULL, spline.int=NULL, params=NULL, which.param=NULL, rplot=4, nplot=1,
brks1=seq(0,1,0.2), brks2=seq(0,1,0.2)){
#precision
A=ggplot(data=Data, aes(x=param.value, y=precision, color=Method))+
geom_line(position = pd)+
geom_point(position = pd)+
stat_smooth(n=spline.int)+
#scale_y_continuous(limits = lims, breaks = brks)+
scale_y_continuous(breaks = brks1)+
scale_x_continuous(breaks = unique(param.value))+
xlab(paste0(colnames(params)[which.param]))+
ylab("Mean Precision")
#Recall
B=ggplot(data=Data, aes(x=param.value, y=recall, color=Method))+
geom_line(position = pd)+
geom_point(position = pd)+
stat_smooth(n=spline.int)+
#scale_y_continuous(limits = lims, breaks = brks)+
scale_y_continuous(breaks = brks2)+
scale_x_continuous(breaks = unique(param.value))+
xlab(paste0(colnames(params)[which.param]))+
ylab("Mean Recall")
# #Specificity
# C=ggplot(data=Data, aes(x=param.value, y=specificity, color=Method))+
#   geom_line(position = pd)+
#   geom_point(position = pd)+
#   stat_smooth(n=spline.int)+
#   xlab(paste0(colnames(params)[which.param]))+
#   ylab("Mean Specificity")
# #FOR
# D=ggplot(data=Data, aes(x=param.value, y=FOR, color=Method))+
#   geom_line(position = pd)+
#   geom_point(position = pd)+
#   stat_smooth(n=spline.int)+
#   xlab(paste0(colnames(params)[which.param]))+
#   ylab("Mean FOR")
#Combine
Z=ggarrange(A,B, labels=c("A","B"), nrow=rplot, ncol=nplot)
plot(Z)
}
##############################################
plot.regular=function(Data=NULL, pd=NULL, params=NULL, which.param=NULL, rplot=4, nplot=1,
brks1=seq(0,1,0.2), brks2=seq(0,1,0.2)){
#Precision
A=ggplot(data=Data, aes(x=param.value, y=precision, color=Method))+
geom_line(position = pd)+
geom_point(position = pd)+
#scale_y_continuous(limits = lims, breaks = brks)+
scale_y_continuous(breaks = brks1)+
scale_x_continuous(breaks = unique(param.value))+
xlab(paste0(colnames(params)[which.param]))+
ylab("Mean Precision")
#Recall
B=ggplot(data=Data, aes(x=param.value, y=recall, color=Method))+
geom_line(position = pd)+
geom_point(position = pd)+
#scale_y_continuous(limits = lims, breaks = brks)+
scale_y_continuous(breaks = brks2)+
scale_x_continuous(breaks = unique(param.value))+
xlab(paste0(colnames(params)[which.param]))+
ylab("Mean Recall")
# #Specificity
# C=ggplot(data=Data, aes(x=param.value, y=specificity, color=Method))+
#   geom_line(position = pd)+
#   geom_point(position = pd)+
#   xlab(paste0(colnames(params)[which.param]))+
#   ylab("Mean Specificity")
# #FOR
# D=ggplot(data=Data, aes(x=param.value, y=FOR, color=Method))+
#   geom_line(position = pd)+
#   geom_point(position = pd)+
#   xlab(paste0(colnames(params)[which.param]))+
#   ylab("Mean FOR")
#Combine
Z=ggarrange(A,B, labels=c("A","B"), nrow=rplot, ncol=nplot)
plot(Z)
}
##############################################
plot.sim.metrics=function(metrics.mrgn=NULL, metrics.mrpc=NULL, params=NULL, which.param=2, by.class=FALSE,
which.class=NULL, plot.it=TRUE, spline.it=TRUE, spline.int=10, dodge=0.1,
return.means=TRUE, rplot=4, nplot=1, brks1=seq(0,1,0.2), brks2=seq(0,1,0.2),
save.plot=FALSE, plot.path=""){
library(ggpubr)
pd=position_dodge(dodge)
if(by.class==TRUE){
#calc averages within a certain model class
metrics.mrgn.m=subset(metrics.mrgn, truth==which.class)
metrics.mrpc.m=subset(metrics.mrpc, truth==which.class)
#get mean scores across parameter within class
avg.scores.all=get.avg(x.mrgn = metrics.mrgn.m,
x.mrpc = metrics.mrpc.m,
params = params,
which.param = which.param)
}else{
#get mean scores across parameter
avg.scores.all=get.avg(x.mrgn = metrics.mrgn,
x.mrpc = metrics.mrpc,
params = params,
which.param = which.param)
}
#plotting - splined plots
if(plot.it==TRUE & spline.it==TRUE){
#for plot saving
if(save.plot==TRUE){
pdf(plot.path, height = 8, width = 12)
plot.spline(avg.scores.all,
pd = pd,
spline.int = spline.int,
params = params,
which.param = which.param,
rplot = rplot,
nplot = nplot,
brks1 = brks1,
brks2 = brks2)
dev.off()
}else{
plot.spline(avg.scores.all,
pd = pd,
spline.int = spline.int,
params = params,
which.param = which.param,
rplot = rplot,
nplot = nplot,
brks1 = brks1,
brks2 = brks2)
}
#plotting - regular plots
}else if(plot.it==TRUE & spline.it==FALSE){
if(save.plot==TRUE){
pdf(plot.path, height = 8, width = 12)
plot.regular(Data = avg.scores.all,
pd = pd,
params = params,
which.param = which.param,
rplot = rplot,
nplot = nplot,
brks1 = brks1,
brks2 = brks2)
dev.off()
}else{
plot.regular(Data = avg.scores.all,
pd = pd,
params = params,
which.param = which.param,
rplot = rplot,
nplot = nplot,
brks1 = brks1,
brks2 = brks2)
}
}
#return mean score and sdev data
if(return.means==TRUE){
return(avg.scores.all)
}
}
#all models across sample size
X=plot.sim.metrics(metrics.mrgn=mrgn.metrics,
metrics.mrpc=mrpc.metrics,
params=params,
which.param=2,
by.class=FALSE,
which.class=NULL,
plot.it=TRUE,
spline.it=TRUE,
spline.int=15,
dodge=0.1,
return.means=TRUE,
rplot=2,
nplot=1,
brks1 = seq(0.988,1,0.001),
brks2 = seq(0.7,1,0.05),
save.plot=FALSE,
plot.path="C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Simplots/precision.recall.sample.size.pdf")
plot.spline=function(Data=NULL, pd=NULL, spline.int=NULL, params=NULL, which.param=NULL, rplot=4, nplot=1,
brks1=seq(0,1,0.2), brks2=seq(0,1,0.2)){
#precision
A=ggplot(data=Data, aes(x=param.value, y=precision, color=Method))+
geom_line(position = pd)+
geom_point(position = pd)+
stat_smooth(n=spline.int)+
#scale_y_continuous(limits = lims, breaks = brks)+
scale_y_continuous(breaks = brks1)+
scale_x_continuous(breaks = unique(Data$param.value))+
xlab(paste0(colnames(params)[which.param]))+
ylab("Mean Precision")
#Recall
B=ggplot(data=Data, aes(x=param.value, y=recall, color=Method))+
geom_line(position = pd)+
geom_point(position = pd)+
stat_smooth(n=spline.int)+
#scale_y_continuous(limits = lims, breaks = brks)+
scale_y_continuous(breaks = brks2)+
scale_x_continuous(breaks = unique(Data$param.value))+
xlab(paste0(colnames(params)[which.param]))+
ylab("Mean Recall")
# #Specificity
# C=ggplot(data=Data, aes(x=param.value, y=specificity, color=Method))+
#   geom_line(position = pd)+
#   geom_point(position = pd)+
#   stat_smooth(n=spline.int)+
#   xlab(paste0(colnames(params)[which.param]))+
#   ylab("Mean Specificity")
# #FOR
# D=ggplot(data=Data, aes(x=param.value, y=FOR, color=Method))+
#   geom_line(position = pd)+
#   geom_point(position = pd)+
#   stat_smooth(n=spline.int)+
#   xlab(paste0(colnames(params)[which.param]))+
#   ylab("Mean FOR")
#Combine
Z=ggarrange(A,B, labels=c("A","B"), nrow=rplot, ncol=nplot)
plot(Z)
}
##############################################
plot.regular=function(Data=NULL, pd=NULL, params=NULL, which.param=NULL, rplot=4, nplot=1,
brks1=seq(0,1,0.2), brks2=seq(0,1,0.2)){
#Precision
A=ggplot(data=Data, aes(x=param.value, y=precision, color=Method))+
geom_line(position = pd)+
geom_point(position = pd)+
#scale_y_continuous(limits = lims, breaks = brks)+
scale_y_continuous(breaks = brks1)+
scale_x_continuous(breaks = unique(Data$param.value))+
xlab(paste0(colnames(params)[which.param]))+
ylab("Mean Precision")
#Recall
B=ggplot(data=Data, aes(x=param.value, y=recall, color=Method))+
geom_line(position = pd)+
geom_point(position = pd)+
#scale_y_continuous(limits = lims, breaks = brks)+
scale_y_continuous(breaks = brks2)+
scale_x_continuous(breaks = unique(Data$param.value))+
xlab(paste0(colnames(params)[which.param]))+
ylab("Mean Recall")
# #Specificity
# C=ggplot(data=Data, aes(x=param.value, y=specificity, color=Method))+
#   geom_line(position = pd)+
#   geom_point(position = pd)+
#   xlab(paste0(colnames(params)[which.param]))+
#   ylab("Mean Specificity")
# #FOR
# D=ggplot(data=Data, aes(x=param.value, y=FOR, color=Method))+
#   geom_line(position = pd)+
#   geom_point(position = pd)+
#   xlab(paste0(colnames(params)[which.param]))+
#   ylab("Mean FOR")
#Combine
Z=ggarrange(A,B, labels=c("A","B"), nrow=rplot, ncol=nplot)
plot(Z)
}
##############################################
plot.sim.metrics=function(metrics.mrgn=NULL, metrics.mrpc=NULL, params=NULL, which.param=2, by.class=FALSE,
which.class=NULL, plot.it=TRUE, spline.it=TRUE, spline.int=10, dodge=0.1,
return.means=TRUE, rplot=4, nplot=1, brks1=seq(0,1,0.2), brks2=seq(0,1,0.2),
save.plot=FALSE, plot.path=""){
library(ggpubr)
pd=position_dodge(dodge)
if(by.class==TRUE){
#calc averages within a certain model class
metrics.mrgn.m=subset(metrics.mrgn, truth==which.class)
metrics.mrpc.m=subset(metrics.mrpc, truth==which.class)
#get mean scores across parameter within class
avg.scores.all=get.avg(x.mrgn = metrics.mrgn.m,
x.mrpc = metrics.mrpc.m,
params = params,
which.param = which.param)
}else{
#get mean scores across parameter
avg.scores.all=get.avg(x.mrgn = metrics.mrgn,
x.mrpc = metrics.mrpc,
params = params,
which.param = which.param)
}
#plotting - splined plots
if(plot.it==TRUE & spline.it==TRUE){
#for plot saving
if(save.plot==TRUE){
pdf(plot.path, height = 8, width = 12)
plot.spline(avg.scores.all,
pd = pd,
spline.int = spline.int,
params = params,
which.param = which.param,
rplot = rplot,
nplot = nplot,
brks1 = brks1,
brks2 = brks2)
dev.off()
}else{
plot.spline(avg.scores.all,
pd = pd,
spline.int = spline.int,
params = params,
which.param = which.param,
rplot = rplot,
nplot = nplot,
brks1 = brks1,
brks2 = brks2)
}
#plotting - regular plots
}else if(plot.it==TRUE & spline.it==FALSE){
if(save.plot==TRUE){
pdf(plot.path, height = 8, width = 12)
plot.regular(Data = avg.scores.all,
pd = pd,
params = params,
which.param = which.param,
rplot = rplot,
nplot = nplot,
brks1 = brks1,
brks2 = brks2)
dev.off()
}else{
plot.regular(Data = avg.scores.all,
pd = pd,
params = params,
which.param = which.param,
rplot = rplot,
nplot = nplot,
brks1 = brks1,
brks2 = brks2)
}
}
#return mean score and sdev data
if(return.means==TRUE){
return(avg.scores.all)
}
}
#all models across sample size
X=plot.sim.metrics(metrics.mrgn=mrgn.metrics,
metrics.mrpc=mrpc.metrics,
params=params,
which.param=2,
by.class=FALSE,
which.class=NULL,
plot.it=TRUE,
spline.it=TRUE,
spline.int=15,
dodge=0.1,
return.means=TRUE,
rplot=2,
nplot=1,
brks1 = seq(0.988,1,0.001),
brks2 = seq(0.7,1,0.05),
save.plot=FALSE,
plot.path="C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/Simplots/precision.recall.sample.size.pdf")
