t1.1 = table(MRGN = mrgn.edge.ind, Truth = params$true.score)
colnames(t1.1) = row.names(t1.1)=c("T1-T2 Absent", "T1-T2 Present")
t1.2 = rbind(t1.1, Total = colSums(t1.1), Recall = round(diag(t1.1)/colSums(t1.1),4))
t1.3 = cbind(t1.2, Total = c(rowSums(t1.2)[1:3], " "), Precision = c(round(diag(t1.1)/rowSums(t1.1),4), rep("",2)))
#mrpc
t2.1 = table(MRPC = mrpc.edge.ind, Truth = params$true.score)
colnames(t2.1) = row.names(t2.1)=c("T1-T2 Absent", "T1-T2 Present")
t2.2 = rbind(t2.1, Total = colSums(t2.1), Recall = round(diag(t2.1)/colSums(t2.1),4))
t2.3 = cbind(t2.2, Total = c(rowSums(t2.2)[1:3], " "), Precision = c(round(diag(t2.1)/rowSums(t2.1),4), rep("",2)))
#gmac
t3.1 = rbind(c(0,0),table(GMAC = gmac.edge.ind, Truth = params$true.score))
colnames(t3.1) = row.names(t3.1)=c("T1-T2 Absent", "T1-T2 Present")
t3.2 = rbind(t3.1, Total = colSums(t3.1), Recall = round(diag(t3.1)/colSums(t3.1),4))
t3.3 = cbind(t3.2, Total = c(rowSums(t3.2)[1:3], " "), Precision = c(round(diag(t3.1)/rowSums(t3.1),4), rep("",2)))
#combine
final.t123 = cbind(Method = c(rep(" ", 2), "MRGN", rep(" ", 4), "MRPC", rep(" ", 4), "GMAC", " "),
Description = c(row.names(t1.3), " ", row.names(t2.3), " ", row.names(t3.3)),
rbind(t1.3, rep(" ", 4), t2.3, rep(" ",4), t3.3))
kable(final.t123, caption = "Confusion matrices and precision/recall for MRGN, MRPC, and GMAC showing T1-T2 edge prediction performance on simulated trios of all model types. Here MRGN and MRPC use the correlation - based selection procedure with out filtering. Comparatively, GMAC uses the regression - based procedure with filtering. Columns represent the true case and rows represent the inferred case", row.names = F, booktabs = T)
#write.csv(final.t123, "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Manuscript/Tables/T1.T2.edge.results.15confs.csv", row.names = T)
#second set of tables with common child and intermediate variable filtering of the regression - based procedure for MRGN and MRPC to compare the three algorithms when the filtering method is the better GMAC method
#params=loadRData(file="C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/GMACvMRGN_sim/simulated_data_all_conf_types/sim_set_3_data/mrpc_v_mrgn_v_gmac_5k_params_all_mods_conf_types.RData")
mrgn.inf.w.f=loadRData(file="C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/GMACvMRGN_sim/simulated_data_all_conf_types/sim_set_3_data/int_and_child_filtered_data/mrgn_5k_inf_results_all_confs_filtered_all_mods.RData")
mrgn.reg.res.w.f=loadRData(file="C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/GMACvMRGN_sim/simulated_data_all_conf_types/sim_set_3_data/int_and_child_filtered_data/mrgn_5k_regres_results_all_confs_filtered_all_mods.RData")
mrpc.inf.w.f=loadRData(file="C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/GMACvMRGN_sim/simulated_data_all_conf_types/sim_set_3_data/int_and_child_filtered_data/mrpc_5k_small_results_all_confs_filtered_all_mods.RData")
conf.list.w.f=loadRData(file = "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/GMACvMRGN_sim/simulated_data_all_conf_types/sim_set_3_data/int_and_child_filtered_data/mrpc_5k_conf_list_all_confs_filtered_all_mods.RData")
params=loadRData(file="C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/GMACvMRGN_sim/simulated_data_all_conf_types/sim_set_3_data/mrpc_v_mrgn_v_gmac_5k_params_all_mods_conf_types.RData")
datasets=loadRData(file="C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/GMACvMRGN_sim/simulated_data_all_conf_types/sim_set_3_data/mrgn_v_gmac_v_mrpc_5k_datasets_all_mods_conf_types.RData")
conf.list = loadRData(fileName ="C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/GMACvMRGN_sim/simulated_data_all_conf_types/sim_set_3_data/int_and_child_filtered_data/mrgn_5k_conf_list_all_confs_filtered_all_mods.RData")
master.table2 = master.table
master.table2$MRGN.pval.b21 = unlist(lapply(mrgn.reg.res.w.f, function(x) x[,8]))
master.table2$MRGN.pval.b22 = unlist(lapply(mrgn.reg.res.w.f, function(x) x[,10]))
master.table2$mrpc.infer = unlist(lapply(mrpc.inf.w.f, function(x) x$model))
master.table2$mrgn.infer = mrgn.inf.w.f
write.csv(master.table2, "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Manuscript/Tables/summary.table.15confs.results.csv", row.names = T)
mrpc.inf.w.f2=unlist(lapply(mrpc.inf.w.f, function(x) x$model))
mrpc.w.f.adj=lapply(mrpc.inf.w.f, function(x) x$Adj)
mrgn.w.f.adj=lapply(mrgn.inf.w.f, get.adj.from.class)
true.adj=lapply(convert.truth(params$model), get.adj.from.class)
x1.1 = table(MRGN = convert.cats(mrgn.inf.w.f), TRUTH = convert.truth(params$model))
x1.2 = rbind(x1.1, Total = colSums(x1.1), Recall = round(diag(x1.1)/colSums(x1.1),4))
x1.3 = cbind(x1.2, Total = c(rowSums(x1.2[1:7,]), " "), Precision = c(round(diag(x1.2)/rowSums(x1.2[1:5,]),4), rep(" ", 3)))
# kable(x3, digits = 2,
#       caption = "Confusion matrix comparing the inferred model of MRGN (rows) to the true model (columns)")
x2.1 = table(MRPC = convert.cats(mrpc.inf.w.f2), TRUTH = convert.truth(params$model))
x2.2 = rbind(x2.1, Total = colSums(x2.1), Recall = round(diag(x2.1)/colSums(x2.1),4))
x2.3 = cbind(x2.2, Total = c(rowSums(x2.2[1:7,]), " "), Precision = c(round(diag(x2.2)/rowSums(x2.2[1:5,]),4), rep(" ", 3)))
final.x12 = cbind(Method = c(rep(" ", 4), "MRGN", rep(" ", 7), "MRPC", rep(" ", 4)),
Description = c(rownames(x1.3), " ", rownames(x2.3)),
rbind(x1.3, rep(" ", 8), x2.3))
kable(final.x12, row.names = F, caption = "Confusion matrix showing the class-based performance of MRGN and MRPC after applying the GMAC confounder selection procedure with common child and intermediate variable filtering. True class labels are represented in the columns and inferred class labels in the rows. Notice that GMAC method (with filtering) markedly improves both the precision and recall of MRGN for models M0 and M3 at a qualitatively small cost to the recall for classes M1 and M2", booktabs = T)
#---------edge-based------------------------
write.csv(final.x12, "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Manuscript/Tables/class.MRGN.MRPC.results.15confs.csv", row.names = T)
edge.metrics.mrgn.wf=as.data.frame(matrix(0, nrow = 1500, ncol = 4))
colnames(edge.metrics.mrgn.wf)=c("prec_edge", "recall", "specificity", "FOR")
edge.metrics.mrpc.wf=as.data.frame(matrix(0, nrow = 1500, ncol = 4))
colnames(edge.metrics.mrpc.wf)=c("prec_edge", "recall", "specificity", "FOR")
for(i in 1:1500){
edge.metrics.mrgn.wf[i,] = get.metrics(Truth = convert.truth(params$model)[i],
Inferred = mrgn.w.f.adj[[i]],
get.adj.truth = TRUE)
edge.metrics.mrpc.wf[i,] = get.metrics(Truth = convert.truth(params$model)[i],
Inferred = mrpc.w.f.adj[[i]],
get.adj.truth = TRUE)
}
edge.met.tab.mrgn.wf = as.data.frame(matrix(0, nrow = 4, ncol = 5))
edge.met.tab.mrpc.wf = as.data.frame(matrix(0, nrow = 4, ncol = 5))
mod.class = c("M0","M1","M2","M3","M4")
colnames(edge.met.tab.mrgn.wf)=colnames(edge.met.tab.mrpc.wf)=mod.class
for(i in 1:length(mod.class)){
edge.met.tab.mrgn.wf[,i] = colMeans(edge.metrics.mrgn.wf[which(convert.truth(params$model)==mod.class[i]),], na.rm = T)
edge.met.tab.mrpc.wf[,i] = colMeans(edge.metrics.mrpc.wf[which(convert.truth(params$model)==mod.class[i]),], na.rm = T)
}
#  edge.met.tab =  cbind.data.frame(MRPC.LOND = colMeans(edge.metrics.mrpc.LOND, na.rm = T),
#                                 MRPC.LOND.SD = apply(edge.metrics.mrpc.LOND, 2, sd, na.rm = TRUE),
#                                 MRPC.ADDIS = colMeans(edge.metrics.mrpc.ADDIS, na.rm = T),
#                                 MRPC.ADDIS.SD = apply(edge.metrics.mrpc.ADDIS, 2 , sd, na.rm = TRUE))
#
row.names(edge.met.tab.mrgn.wf) = row.names(edge.met.tab.mrpc.wf) = c("Precision", "Recall", "Specificity", "False Omission Rate")
#combine tables
edge.met.final.wf = cbind( Method = c(rep(" ", 2), "MRGN", rep(" ",4), "MRPC", " "),
Metric = c(row.names(edge.met.tab.mrgn.wf), " ", row.names(edge.met.tab.mrpc.wf)),
rbind(round(edge.met.tab.mrgn.wf,4), rep(" ", 6), round(edge.met.tab.mrpc.wf,4)))
kable(edge.met.final.wf, caption = "Within - class mean edge-based performances for MRGN and MRPC after applying the GMAC confounder selection procedure with common child and intermediate variable filtering", row.names = F,
booktabs = T)
write.csv(edge.met.final.wf, "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Manuscript/Tables/edge.results.MRGN.MRPC.15confs.csv", row.names = T)
#--------T1-T2-edge-only-------------------
params$true.score = unlist(lapply(true.adj, ind.med.edge))
mrgn.edge.ind.w.f = unlist(lapply(mrgn.w.f.adj, ind.med.edge))
mrpc.edge.ind.w.f = unlist(lapply(mrpc.w.f.adj, ind.med.edge))
#mrgn
t1.1 = table(MRGN = mrgn.edge.ind.w.f, Truth = params$true.score)
colnames(t1.1) = row.names(t1.1)=c("T1-T2 Absent", "T1-T2 Present")
t1.2 = rbind(t1.1, Total = colSums(t1.1), Recall = round(diag(t1.1)/colSums(t1.1),4))
t1.3 = cbind(t1.2, Total = c(rowSums(t1.2)[1:3], " "), Precision = c(round(diag(t1.1)/rowSums(t1.1),4), rep("",2)))
#mrpc
t2.1 = table(MRPC = mrpc.edge.ind.w.f, Truth = params$true.score)
colnames(t2.1) = row.names(t2.1)=c("T1-T2 Absent", "T1-T2 Present")
t2.2 = rbind(t2.1, Total = colSums(t2.1), Recall = round(diag(t2.1)/colSums(t2.1),4))
t2.3 = cbind(t2.2, Total = c(rowSums(t2.2)[1:3], " "), Precision = c(round(diag(t2.1)/rowSums(t2.1),4), rep("",2)))
#gmac
t3.1 = rbind(c(0,0),table(GMAC = gmac.edge.ind, Truth = params$true.score))
colnames(t3.1) = row.names(t3.1)=c("T1-T2 Absent", "T1-T2 Present")
t3.2 = rbind(t3.1, Total = colSums(t3.1), Recall = round(diag(t3.1)/colSums(t3.1),4))
t3.3 = cbind(t3.2, Total = c(rowSums(t3.2)[1:3], " "), Precision = c(round(diag(t3.1)/rowSums(t3.1),4), rep("",2)))
#combine
final.t123 = cbind(Method = c(rep(" ", 2), "MRGN", rep(" ", 4), "MRPC", rep(" ", 4), "GMAC", " "),
Description = c(row.names(t1.3), " ", row.names(t2.3), " ", row.names(t3.3)),
rbind(t1.3, rep(" ", 4), t2.3, rep(" ",4), t3.3))
kable(final.t123, caption = "Confusion matrices and precision/recall for MRGN, MRPC, and GMAC showing T1-T2 edge prediction when both MRGN and MRPC use the GMAC confounder selection procedure with confounder variable filtering",
booktabs = T)
write.csv(final.t123, "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Manuscript/Tables/T1.T2.edge.results.15confs.csv", row.names = T)
# #######################-plot-to-show-sensitivity-to-conf-selection-#######################
# #here we make a plot to show how power and precision is affected by errors in the conf sel
# #we consider the trues all the U designated confounders
# #we consider any W or Z variables in the selected set as errors since they should have been
# #removed by filtering
# just.data = lapply(datasets, function(x) x$data)
# true.confs = lapply(just.data, function(x) colnames(x)[-c(1:6, (dim(x)[2]-1):dim(x)[2])])
# sel.confs = lapply(conf.list, function(x) colnames(x))
#
# conf.fp = unlist(lapply(as.list(c(1:1500)), function(x,y,z) length(which(is.na(match(y[[x]], z[[x]])))),
#                             y = sel.confs, z = true.confs) )
# conf.fn = unlist(lapply(as.list(c(1:1500)), function(x,y,z) length(which(is.na(match(z[[x]], y[[x]])))),
#                             y = sel.confs, z = true.confs) )
#
# # fn.fp = cbind.data.frame(fp = conf.fp, fn = conf.fn)
# # #plot the relationship between false positives and false negatives
# # AA=ggplot(data = fn.fp, aes(x = as.factor(fp), y = fn))+
# #   geom_point()+geom_boxplot()
# fp.errors = sort(unique(conf.fp))
# tab1 = cbind.data.frame(inf.mrgn = mrgn.inf.w.f, inf.mrpc = mrpc.inf.w.f2, num.errors = conf.fp)
# tab2 = cbind.data.frame(edge.metrics.mrgn[,1:2], edge.metrics.mrpc[,1:2], conf.fp)
# colnames(tab2) = c(paste0("MRGN_", colnames(edge.metrics.mrgn)[1:2]),
#                    paste0("MRPC_", colnames(edge.metrics.mrpc)[1:2]),
#                    "num.errors")
# error.summary.mrgn = error.summary.mrpc = as.data.frame(matrix(0, nrow = length(fp.errors), ncol = 6))
# colnames(error.summary.mrgn) = colnames(error.summary.mrpc) =
#   c("Method", "Number.of.Errors",
#     paste0("class_",c("Precision", "Recall")),
#     paste0("Edge_",c("Precision", "Recall")))
# for(i in 1:length(fp.errors)){
#   cm.mrgn = table(inf = convert.cats(subset(tab1, num.errors == fp.errors[i])$inf.mrgn),
#                   convert.truth(params$model[which(conf.fp==fp.errors[i])]))
#
#
#   cm.mrpc = table(inf = convert.cats(subset(tab1, num.errors == fp.errors[i])$inf.mrpc),
#                   convert.truth(params$model[which(conf.fp==fp.errors[i])]))
#   # print(cm.mrpc)
#   # print(sum(cm.mrpc))
#   # print(sum(diag(cm.mrpc)))
#   edge.perf.mrgn = colMeans(tab2[which(tab2$num.errors == fp.errors[i]), 1:2], na.rm = T)
#   #print(edge.perf.mrgn)
#   edge.perf.mrpc = colMeans(tab2[which(tab2$num.errors == fp.errors[i]), 3:4], na.rm = T)
#   #print(edge.perf.mrpc)
#   if(i == 8){
#     mrpc.prec.rec = c(sum(diag(cm.mrpc))/sum(colSums(cm.mrpc)), sum(diag(cm.mrpc))/sum(rowSums(cm.mrpc)))
#     mrgn.prec.rec = c(sum(diag(cm.mrgn))/sum(colSums(cm.mrgn)), sum(diag(cm.mrgn))/sum(rowSums(cm.mrgn)))
#   }else{
#     mrpc.prec.rec = c(sum(diag(cm.mrpc))/sum(colSums(cm.mrpc)), sum(diag(cm.mrpc))/sum(rowSums(cm.mrpc)[1:5]))
#     mrgn.prec.rec = c(sum(diag(cm.mrgn))/sum(colSums(cm.mrgn)), sum(diag(cm.mrgn))/sum(rowSums(cm.mrgn)[1:5]))
#   }
#
#
#   error.summary.mrpc[i, 1] = "MRPC"
#   error.summary.mrpc[i, 2:4] = c(fp.errors[i], mrpc.prec.rec)
#   error.summary.mrpc[i, 5:6] = c(edge.perf.mrpc)
#   error.summary.mrgn[i, 1] = "MRGN"
#   error.summary.mrgn[i, 2:4] = c(fp.errors[i], mrgn.prec.rec)
#   error.summary.mrgn[i, 5:6] = c(edge.perf.mrgn)
#
# }
# plot.data = rbind.data.frame(error.summary.mrgn, error.summary.mrpc)
# A=ggplot(data = plot.data,
#        aes(x = Number.of.Errors, y = class_Precision, color = Method))+
#   geom_point()+geom_line()+theme_classic()+geom_smooth()+
#   scale_x_continuous(breaks = c(fp.errors))+
#   scale_y_continuous(breaks = seq(0, 1, 0.1))
# B=ggplot(data = plot.data,
#        aes(x = Number.of.Errors, y = class_Recall, color = Method))+
#   geom_point()+geom_line()+theme_classic()+geom_smooth()+
#   scale_x_continuous(breaks = c(fp.errors))+
#   scale_y_continuous(breaks = seq(0, 1, 0.1))
# C=ggplot(data = plot.data,
#        aes(x = Number.of.Errors, y = Edge_Precision, color = Method))+
#   geom_point()+geom_line()+theme_classic()+geom_smooth()+
#   scale_x_continuous(breaks = c(fp.errors))+
#   scale_y_continuous(breaks = seq(0.8, 1, 0.05))
# D=ggplot(data = plot.data,
#        aes(x = Number.of.Errors, y = Edge_Recall, color = Method))+
#   geom_point()+geom_line()+theme_classic()+geom_smooth()+
#   scale_x_continuous(breaks = c(fp.errors))+
#   scale_y_continuous(breaks = seq(0.6, 1, 0.05))
#
# E=ggarrange(A,B,C,D, labels = c("A","B","C","D"), nrow = 2, ncol = 2, common.legend = T)
# #plot(E)
colnames(params)[-c(1,7)]=c("Residual SD", "Minor Allele Frequency", "SNP Signal", "T1 - T2 Signal", "Number of Unknown Confounders")
#T1 - T2 edge metrics
mrgn.metrics = cbind.data.frame(Method = rep("MRGN", 1500),
truth = params$true.score,
inf = mrgn.edge.ind.w.f)
mrpc.metrics = cbind.data.frame(Method = rep("MRPC", 1500),
truth = params$true.score,
inf = mrpc.edge.ind.w.f)
gmac.metrics = cbind.data.frame(Method = rep("GMAC", 1500),
truth = params$true.score,
inf = gmac.edge.ind)
A=plot.sim.metrics(metrics.mrgn = mrgn.metrics,
metrics.mrpc = mrpc.metrics,
metrics.gmac = gmac.metrics,
params = params,
which.param = 2,
by.class=FALSE,
use.metric = "prec_rec",
which.class=NULL,
plot.it=TRUE,
spline.it=TRUE,
spline.int=10,
dodge=0.01,
return.means=TRUE,
rplot=2,
nplot=1,
xbrks = seq(0.15, 1.5, 0.15),
brks1 = seq(0, 1, 0.05),
include.gmac = T,
save.plot=TRUE,
plot.path=paste0("C:/Users/Bruin/Documents/GitHub/MRGN_extra",
"/Manuscript/Figures/sd.mrgn.mrpc.gmac.pdf"))
B=plot.sim.metrics(metrics.mrgn = mrgn.metrics,
metrics.mrpc = mrpc.metrics,
metrics.gmac = gmac.metrics,
params = params,
which.param = 3,
by.class=FALSE,
which.class=NULL,
plot.it=TRUE,
spline.it=TRUE,
spline.int=15,
dodge=0.01,
return.means=TRUE,
rplot=2,
nplot=1,
xbrks = seq(0, 0.5, 0.05),
brks1 = seq(0.45, 1, 0.05),
brks2 = seq(0, 1, 0.1),
save.plot=TRUE,
plot.path=paste0("C:/Users/Bruin/Documents/GitHub/MRGN_extra",
"/Manuscript/Figures/minor.freq.T1T2.edge.mrgn.mrpc.gmac.pdf"))
C=plot.sim.metrics(metrics.mrgn = mrgn.metrics,
metrics.mrpc = mrpc.metrics,
metrics.gmac = gmac.metrics,
params = params,
which.param = 4,
by.class=FALSE,
which.class=NULL,
plot.it=TRUE,
spline.it=TRUE,
spline.int=5,
dodge=0.01,
return.means=TRUE,
rplot=2,
nplot=1,
xbrks = seq(0.5, 1.5, 0.1),
brks1 = seq(0.5, 1, 0.05),
brks2 = seq(0.55, 1, 0.05),
save.plot=TRUE,
plot.path=paste0("C:/Users/Bruin/Documents/GitHub/MRGN_extra",
"/Manuscript/Figures/snp.signal.T1T2.edge.mrgn.mrpc.gmac.pdf"))
C=plot.sim.metrics(metrics.mrgn = mrgn.metrics,
metrics.mrpc = mrpc.metrics,
metrics.gmac = gmac.metrics,
params = params,
which.param = 5,
by.class=FALSE,
which.class=NULL,
plot.it=TRUE,
spline.it=TRUE,
spline.int=5,
dodge=0.01,
return.means=TRUE,
rplot=2,
nplot=1,
xbrks = seq(0.5, 1, 0.05),
brks1 = seq(0.5, 1, 0.05),
brks2 = seq(0.4, 1, 0.05),
save.plot=TRUE,
plot.path=paste0("C:/Users/Bruin/Documents/GitHub/MRGN_extra",
"/Manuscript/Figures/med.signal.T1T2.edge.mrgn.mrpc.gmac.pdf"))
D=plot.sim.metrics(metrics.mrgn = mrgn.metrics,
metrics.mrpc = mrpc.metrics,
metrics.gmac = gmac.metrics,
params = params,
which.param = 6,
by.class=FALSE,
which.class=NULL,
plot.it=TRUE,
spline.it=TRUE,
spline.int=15,
dodge=0.01,
return.means=TRUE,
rplot=2,
nplot=1,
xbrks = seq(1, 15, 1),
brks1 = seq(0.5, 1, 0.05),
brks2 = seq(0.5, 1, 0.05),
save.plot=TRUE,
plot.path=paste0("C:/Users/Bruin/Documents/GitHub/MRGN_extra",
"/Manuscript/Figures/num.conf.T1T2.edge.mrgn.mrpc.gmac.pdf"))
#######################-Many-Confs-#####################################
#this section focuses on comparing MRGN and GMAC when there are many confounders for each trio
#both methods use regression conf selection with int and child filtering::
#===============================================
#many.conf.datasets=loadRData(file="C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/GMACvMRGN_sim/simulated_data_all_conf_types/sim_set_3_data/many_conf_data/mrgn_v_gmac_v_mrpc_300_datasets_all_mods_conf_types.RData")
many.conf.params=loadRData(file="C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/GMACvMRGN_sim/simulated_data_all_conf_types/sim_set_3_data/many_conf_data/mrpc_v_mrgn_v_gmac_300_params_all_mods_conf_types.RData")
#datasets2 = lapply(datasets, function(x) x$data)
mrgn.many.conf.inf = loadRData(file= "C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/GMACvMRGN_sim/simulated_data_all_conf_types/sim_set_3_data/many_conf_data/mrgn_300_inf_results_all_confs_all_mods.RData")
master.table.many.conf = loadRData(file="C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/GMACvMRGN_sim/simulated_data_all_conf_types/sim_set_3_data/many_conf_data/master_table_MANY_CONF_all_confs_all_mods.RData")
params.with.mrgn.comp.time = loadRData("C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/GMACvMRGN_sim/simulated_data_all_conf_types/sim_set_3_data/diagnostics/mrgn_many_conf_with_comp_times.RData")
gmac.trans.many.conf = loadRData("C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/GMACvMRGN_sim/simulated_data_all_conf_types/sim_set_3_data/many_conf_data/gmac_300_trans_results_all_all_mods_conf_types_preproc.RData")
gmac.cis.many.conf = loadRData("C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/GMACvMRGN_sim/simulated_data_all_conf_types/sim_set_3_data/many_conf_data/gmac_300_cis_results_all_mods_all_conf_types_proproc.RData")
#comp time table
times =  t(cbind.data.frame(MRGN = c(sum(params.with.mrgn.comp.time$Time.to.compute.mrgn),
mean(params.with.mrgn.comp.time$Time.to.compute.mrgn)*60),
GMAC = c(39.20,(39.33333/300)*60)))
colnames(times) = c("Est. Time to Compute 300 trios (mins)", "Est. Time to Compute Each Trio (sec)")
kable(times, digits = 5, caption = "Times for computing all 300 trios with the selected confounders and an estimated per trio computation times. Trios were simulated from the five model structures with varying numbers of confounders (between 15 and 50), one intermediate variable and one common child variable. MRGN is approximately 150 times faster than GMAC", row.names = T)
mrgn.adj=lapply(mrgn.many.conf.inf, get.adj.from.class)
true.adj=lapply(convert.truth(many.conf.params$model), get.adj.from.class)
gmac.binary = master.table.many.conf$gmac.infer
gmac.binary[which(gmac.binary != "No.Med")] = "Mediation"
gmac.binary2 = gmac.binary
gmac.binary2[gmac.binary == "Mediation"] = "T1 - T2 Edge Present"
#confusion matrices
x1.1 = table(MRGN = convert.cats(mrgn.many.conf.inf), TRUTH = convert.truth(many.conf.params$model))
x1.2 = rbind(x1.1, Total = colSums(x1.1), Recall = round(diag(x1.1)/colSums(x1.1),4))
x1.3 = cbind(x1.2, Total = c(rowSums(x1.2[1:7,]), " "), Precision = c(round(diag(x1.2)/rowSums(x1.2[1:5,]),4), rep(" ", 3)))
# kable(x3, digits = 2,
#       caption = "Confusion matrix comparing the inferred model of MRGN (rows) to the true model (columns)")
x2.1 = table(GMAC = gmac.binary2, TRUTH = convert.truth(many.conf.params$model))
x2.1.1 = rbind(`T1 - T2 Edge Absent`=rep(0,5), x2.1)
x2.2 = rbind(x2.1.1, Total = colSums(x2.1.1), Recall = c(0,1,1,0,1))
x2.3 = cbind(x2.2, Total = c(rowSums(x2.2[1:3,]), " "), Precision = c(0, (63+43+71)/sum(x2.2[2,]), rep(" ", 2)))
final.x12 = cbind(Method = c(rep(" ", 3), "MRGN", rep(" ", 6), "GMAC", rep(" ", 2)),
Description = c(rownames(x1.3), " ", rownames(x2.3)),
rbind.data.frame(x1.3, rep(" ", 8), x2.3))
#print final table
kable(final.x12, row.names = F, caption = "Confusion matrix showing the class-based performance of MRGN and GMAC on 300 trios after using regression based confounder selection and common child and intermediate variable filtering. For GMAC, precision and recall were calculated according to which model types have a T1-T2 edge. ", booktabs = T)
edge.metrics.mrgn=as.data.frame(matrix(0, nrow = 300, ncol = 4))
colnames(edge.metrics.mrgn)=c("prec_edge", "recall", "specificity", "FOR")
for(i in 1:300){
edge.metrics.mrgn[i,] = get.metrics(Truth = convert.truth(many.conf.params$model)[i],
Inferred = mrgn.adj[[i]],
get.adj.truth = TRUE)
}
edge.met.tab.mrgn = as.data.frame(matrix(0, nrow = 4, ncol = 5))
mod.class = c("M0","M1","M2","M3","M4")
colnames(edge.met.tab.mrgn)=mod.class
for(i in 1:length(mod.class)){
edge.met.tab.mrgn[,i] = colMeans(edge.metrics.mrgn[which(convert.truth(many.conf.params$model)==mod.class[i]),], na.rm = T)
}
#  edge.met.tab =  cbind.data.frame(MRPC.LOND = colMeans(edge.metrics.mrpc.LOND, na.rm = T),
#                                 MRPC.LOND.SD = apply(edge.metrics.mrpc.LOND, 2, sd, na.rm = TRUE),
#                                 MRPC.ADDIS = colMeans(edge.metrics.mrpc.ADDIS, na.rm = T),
#                                 MRPC.ADDIS.SD = apply(edge.metrics.mrpc.ADDIS, 2 , sd, na.rm = TRUE))
#
row.names(edge.met.tab.mrgn) = c("Precision", "Recall", "Specificity", "False Omission Rate")
edge.met.final = cbind( Method = c(rep(" ", 2), "MRGN", ""),
Metric = row.names(edge.met.tab.mrgn),
round(edge.met.tab.mrgn,4))
kable(edge.met.final, caption = "Within - class mean edge-based performances for MRGN for 300 trios with a large number of confounders and using regression - based confounder selection and filtering", row.names = F,
booktabs = T)
# get 0,1 indication of inference for T1 - T2 edge
many.conf.params$true.score = unlist(lapply(true.adj, ind.med.edge))
mrgn.edge.ind = unlist(lapply(mrgn.adj, ind.med.edge))
gmac.edge.ind = apply(cbind(
gmac.cis.many.conf$output.table$Cis_Sig,
gmac.trans.many.conf$output.table$Trans_Sig),
1, ind.gmac)
#mrgn
t1.1 = table(MRGN = mrgn.edge.ind, Truth = many.conf.params$true.score)
colnames(t1.1) = row.names(t1.1)=c("T1-T2 Absent", "T1-T2 Present")
t1.2 = rbind(t1.1, Total = colSums(t1.1), Recall = round(diag(t1.1)/colSums(t1.1),4))
t1.3 = cbind(t1.2, Total = c(rowSums(t1.2)[1:3], " "), Precision = c(round(diag(t1.1)/rowSums(t1.1),4), rep("",2)))
#gmac
t3.1 = rbind(c(0,0),table(GMAC = gmac.edge.ind, Truth = params$true.score))
#gmac
t3.1 = rbind(c(0,0),table(GMAC = gmac.edge.ind, Truth = many.conf.params$true.score))
colnames(t3.1) = row.names(t3.1)=c("T1-T2 Absent", "T1-T2 Present")
t3.2 = rbind(t3.1, Total = colSums(t3.1), Recall = round(diag(t3.1)/colSums(t3.1),4))
t3.3 = cbind(t3.2, Total = c(rowSums(t3.2)[1:3], " "), Precision = c(round(diag(t3.1)/rowSums(t3.1),4), rep("",2)))
#combine
final.t123 = cbind(Method = c(rep(" ", 1), "MRGN", rep(" ", 4), "GMAC", rep(" ", 2)),
Description = c(row.names(t1.3), " ", row.names(t3.3)),
rbind(t1.3, rep(" ",4), t3.3))
kable(final.t123, caption = "Confusion matrices and precision/recall for MRGN, and GMAC showing T1-T2 edge prediction performance on 300 simulated trios where the number of confounders varied from 15 to 50. Columns represent the true case and rows represent the inferred case", row.names = F, booktabs = T)
?GMAC::gmac
paste0("/mnt/ceph/jarredk/MRGN_extra/GTEx_tissues_analysis/Manuscript_results/Prob_trio_plots/",tissues.vec[t],".",trio.idx, ".pdf")
mrgn.reg.res=loadRData(file="C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/GMACvMRGN_sim/simulated_data_all_conf_types/sim_set_3_data/mrgn_5k_regres_results_all_confs_all_mods.RData")
#read in simulation data
params=loadRData(file="C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/GMACvMRGN_sim/simulated_data_all_conf_types/sim_set_3_data/mrpc_v_mrgn_v_gmac_5k_params_all_mods_conf_types.RData")
mrpc.inf=loadRData(file="C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/GMACvMRGN_sim/simulated_data_all_conf_types/sim_set_3_data/mrpc_5k_small_results_all_confs_all_mods.RData")
mrgn.reg.res[1:6, which(params$model == "model0"]
mrgn.reg.res[1:6, which(params$model == "model0")]
dim(mrgn.reg.res)
reg.res = do.call("rbind", mrgn.reg.res)
dim(reg.res)
reg.res[which(params$model == "model0"),1:6]
x = reg.res[which(params$model == "model0"),1:6]
library(prodlim)
row.match(c(1,0,1,1,0,1), x)
row.match(c(1,0,1,1,1,1), x)
x
str(x)
dim(x)
y=apply(x, 1, paste, collapse = ",")
y
dim(y)
length(y)
which(y == c("1,1,0,1"))
which(y == "1,1,0,1,0,1"))
which(y == "1,1,0,1,0,1")
y[which(y == "1,1,0,1,0,1")]
datasets=loadRData(file="C:/Users/Bruin/Documents/GitHub/MRGN_extra/Simulations/GMACvMRGN_sim/simulated_data_all_conf_types/sim_set_3_data/mrgn_v_gmac_v_mrpc_5k_datasets_all_mods_conf_types.RData")
idx = y[which(y == "1,1,0,1,0,1")]
cor(datasets[[idx[1]]][,1:3])
cor(datasets[[idx[1]]]$data[,1:3])
datasets[[idx[1]]]$data[,1:3]
datasets[[idx[1]]]$data[,1:3]
idx[1]
idx = which(y == "1,1,0,1,0,1")
cor(datasets[[idx[1]]]$data[,1:3])
y[idx]
log(1.3)
sort(c(1,2,3), index.return = T)
sort(rnorm(100), index.return = T)
x = matrix(c(6,1,6,3,7,1,6,4), nrow = 4, ncol = 2, byrow = T)
x
idx = sort(x[,1], index.return = T)
idx
x[idx$ix,]
x = matrix(c(6,4,6,3,7,1,6,1), nrow = 4, ncol = 2, byrow = T)
idx = sort(x[,1], index.return = T)
x[idx$ix,]
data = read.csv('C:/Users/Bruin/Desktop/GS Academia/PhD/SEM 3 FALL 2022/Deep Learning/winequality-white.csv', sep=";")
Y = data[,12]
Y
X = data[,-12]
model = lm(Y~X)
colnames(data)
model = lm(quality~., data = data)
summary(model)
model
sum(model$residuals^2)
n = length(model$residuals)
sum(model$residuals^2)/n
summary(model)
getwd()
setwd("C:/Users/Bruin/Documents/Github/MRGN")
getwd()
getwd()
library(devtools)
document()
build()
install()
library(MRGN)
sessionInfo()
?infer.trio
result=infer.trio(M1trio)
print(result)
models = sapply(WBtrios[1:10], function(x) infer.trio(x)$Inferred.Model)
print(models)
stats = sapply(WBtrios[1:10], function(x) infer.trio(x)$Stats)
print(stats)
stats = sapply(WBtrios[1:10], function(x) infer.trio(x))
print(stats)
models = sapply(WBtrios[1:200], function(x) infer.trio(x))
print(models)
library(devtools)
document()
build()
install()
library(MRGN)
library(devtools)
document()
install()
build()
install()
library(MRGN)
?infer.trio
library(MRGN)
?infer.trio
results = sapply(WBtrios[1:10], function(x) infer.trio(x))
print(results)
results = sapply(WBtrios[1:100], function(x) infer.trio(x))
print(results)
results = sapply(WBtrios, function(x) infer.trio(x), use.perm = F)
print(results)
results = sapply(WBtrios, function(x) infer.trio(x), use.perm = F)
print(results)
results = sapply(WBtrios, function(x) infer.trio(x, use.perm = F))
print(results)
results[14,]
which(unlist(results[14,]) == "M2.2")
which(unlist(results[14,]) == "M2.1")
results = sapply(WBtrios, function(x) infer.trio(x, use.perm = T, nperms = 500))
print(results)
summary(as.factor(unlist(results[14,])))
results = sapply(WBtrios, function(x) infer.trio(x, use.perm = T, nperms = 500))
summary(as.factor(unlist(results[14,])))
results = sapply(WBtrios, function(x) infer.trio(x, use.perm = F))
summary(as.factor(unlist(results[14,])))
length(WBtrios)
